Can't find it in one of the big chunks?  Look through the 80100CB0 index
index of loaded compressed binaries in memory
80100CB0, 0x20 each entry
format:
0x0	4	codeword start
0x4	4	codeword end
0x8	4	pointer conversion start
0xC	4	pointer conversion end
0x10	4	RDRAM address when loaded
0x14	4	?
0x18	4	0
0x1C	4	00000100 when the entry is loaded into RDRAM

match the codeword with the codeword<->ROM table in ROM+0x19D40

+-+

ROM proper	+80024C00
+-+-+-+-+-+-+-+
 	80025C60	
 	80025CC0	
 	80025DF0	
 	80025E6C	
 13D0	80025FD0	???	has an infinite loop though!
 14A0	800260A0
 
 1B14	80026714	iterate through ROM index for matching codeword
		accepts: A0=codeword
		returns: V0=p->matching entry offset or 0
 1B70	80026770	returns V0=ROM offset or -1 on fail
		accepts: A0=codeword
 1BDC	800267DC	returns index for matching entry in ROM<->code table
		accepts: A0=codeword
 1C14	80026814

 1E64	80026A64	extract data for an index
		accepts: A0=SP+50, A1=target addy, A2=index, A3=length
 1F44	80026B44
 1FC0	80026BC0
 2000	80026C00

 2210	80026E10	retrieves data from ROM with codeword
		accepts: A0=p->target, A1=codeword, A2=strlen, A3=p->debug string (unused), SP+10=value (unused?)
 22A0	80026EA0
 22D0	80026ED0	clears state of COP0
 2340	80026F40	twiddle status of COP0 Status
		accepts: A0=flags to OR
		fries: T0
 2460	80027060	Yaz0 decompression routine
 25E8	800271E8
 
 26DC	800272DC	removed: would processes KeyWait strings
		now saves A0-A3 -> SP+0-SP+C
		accepts: A0=p->KeyWait string
 26F8	800272F8	removed: 
		now saves A0-A3 -> SP+0-SP+C
 2720	80027320
 
 3BBC	800287BC	???; uses KeyWaitB() strings
		uses pointer table @ 8003DE1C	(0xA)
 3E88	80028A88
	
 48D0	800294D0	calls main loop 8002DFA0 and handles exceptions and faults it may throw
		code at 80029588 only run when 8002DFA0 returns, value indicating error
 4C30	80029830
	
 59F0	8002A5F0	blank controller input table entry; blank 0x18 bytes at A0
		accepts: A0=p->controller input table	[80145B30/48]
 5A10	8002A610	unconditional return
 5A18	8002A618	0->A0+C, 0->A0+12
		accepts: A0=p->controller input table
 5A24	8002A624	V0=TRUE if A1 only buttons currently pressed
		accepts: A0=p->controller input table, A1=button mask
 5A3C	8002A63C	V0=TRUE if A1 currently pressed
		accepts: A0=p->controller input table, A1=button mask
 5A58	8002A658	V0=TRUE if A1 pressed on A0+C
		accepts: A0=p->controller input table, A1=button mask
 5A74	8002A674	V0=TRUE if A1 pressed on A0+12
		accepts: A0=p->controller input table, A1=button mask
 5A90	8002A690	V0=controller cur.digital; V0=A0+0
		accepts: A0=p->controller input table
 5A98	8002A698	V0=A0+C
		accepts: A0=p->controller input table
 5AA0	8002A6A0	V0=current horzontal state
		accepts: A0=p->controller input table
 5AA8	8002A6A8	V0=current vertical state
		accepts: A0=p->controller input table
 5AB0	8002A6B0	save controller stick state {A1,A2}
		accepts: A0=p->controller input table, A1=horz.state, A2=vert.state
 5ABC	8002A6BC	V0=saved horz.state; V0=A0+14
		accepts: A0=p->controller input table
 5AC4	8002A6C4	V0=saved vert.state; V0=A0+15
		accepts: A0=p->controller input table
 5ACC	8002A6CC	redirect to 8002A6BC
		accepts: A0=p->controller input table
 5AEC	8002A6EC	redirect to 8002A6C4
		accepts: A0=p->controller input table
 5B0C	8002A70C	if current stick within bounds, save to A0+14/15
		accepts: A0=p->controller input table
 5BE0	8002A7E0
	
 6B70	8002B770	fprintf(A0,A1,...)
		accepts: A0=p->target, A1=string, A2,A3,SP+10,etc. values for format specifier replacement
	
	8002B9C0
	
 7DAC	8002C9AC	F0=random number 0.0 - 1.0
		returns: F0=number
		fries: AT,V0,V1,T0,T1,T6,T7,T8,F4,F6
 7E00	8002CA00
	
 8F20	8002DB20	
		accepts: A0=p->???, A1=, A2=
 906C	8002DC6C

	8002EB60	exception handler
	8002ED98	??? exception	(masks ~20000000)
	8002EDA4	??? exception	(masks ~40000000)
	8002EDB0	??? exception	(masks ~80000000)
	8002EDD0	??? exception	(masks ~08000000)
	8002EE14	??? exception	(masks ~04000000)
	8002EF7C	??? exception	(masks ~10000000)
	8002EFD8	??? exception	(masks ~02000000)
	8002EFF8	??? exception	(masks ~01000000)
	8002F030	??? exception
 
 A6DC	8002F2DC	move to next block of data
		accepts: A0=p->data block struct
		fries: V0,T9
 A6EC	8002F2EC
	8002F470
 A8C0	8002F4C0	blanks large chunks of data
		accepts: A0=p->source, A1=size
 A960	8002F560
 
	8002F8D4	calls 8002DB20: A0=80041AE8, A1=0, A2=0
	8002F900
 
 B180	8002FD80
 B200	8002FE00	sets cache ??? for A1 bytes at A0 (writable, I know that)
		accepts: A0=p->target, A1=size
 B280	8002FE80
	
 B9B0	800305B0	PIF I/O; V0=nonzero if error occurs
		accepts: A0=mode (0-read; 1-write), A1=p->PIFram buffer
 BA60	80030660
	
 FEA0	80034AA0	adds entry to TLB
 FEF0	80034AF0
 
	80034CE0	sets cache ??? for A1 bytes at A0 (writable, I know that)
		accepts: A0=p->target, A1=size
10160	80034D60

	800358E0	handles PI access
	80035AC0

	80035B20	V0=TRUE if strings A0 and A1 differ
		accepts: A0=p->data1, A1=p->data2, A2=strlen

114E0	800360E0	copy A2 bytes from source A0 to target A1
		accepts: A0=p->source, A1=p->target, A2=strlen
11554	80036154

122D0	80036ED0	unset COP0 status bit 1 (can't remember use)
12340	80036F40	twiddle COP0's status flags
		accepts: A0=flags
		fries: T0
		
141C0	80038DC0	mirror rdram via TLB
14220	80038E20
14280	80038E80
14350	80038F50	V0=COP0 Cause
14360	80038F60
145B0	800391B0
147E0	800393E0
148B0	800394B0
14950	80039550
	800396B0	???
		accepts: A0=p->???, A1=, A2=, A3=, SP+10=, SP+14=, SP+18=p->???, SP+1C=p->???

18580	8003D180	system errors, especially DMA transfers
18ED8	8003DAD8	"KeyWaitB (LRZ up down up down left left right right BA START)"
18F50	8003DB50	"KeyWaitB'(LR left right START) "
18F84	8003DB84	"%s %08x"
18F8C	8003DB8C	"PrintDump%06x"
18FA0	8003DBA0	"%08x"
18FA8	8003DBA8	"Dump"
18FB0	8003DBB0	"SP       PC       (VPC)"
18FC8	8003DBC8	"%08x %08x"
18FD4	8003DBD4	" -> %08x"
18FE0	8003DBE0	"STACK TRACE\rSP       PC       (VPC)\r"
19008	8003DC08	"%08x %08x"
19014	8003DC14	" -> %08x"
19020	8003DC20	"\r"
19024	8003DC24	"$1A38hCallBack (%d) %08x %08x %08x\r$1A37h"
19048	8003DC48	"fault_manager: OS_EVENT_CPU_BREAK received\r"
19080	8003DC80	"fault_manager: OS_EVENT_FAULT received\r"
190B4	8003DCB4	"fault_manager: Unknown message received\r"
190E8	8003DCE8	"__osGetCurrFaultedThread()=%08x\r"
1910C	8003DD0C	"FindFaultedThread()=%08x\r"
19128	8003DD28	"STACK TRACE"
19134	8003DD34	"    CONGRATURATIONS!    "
19150	8003DD50	"All Pages are displayed."
19170	8003DD70	"   THANK YOU!       "
19188	8003DD88	" You are great debugger!"
191A4	8003DDA4	"fault"
191AC	8003DDAC	"HungUp on Thread %d\r"
191C4	8003DDC4	"%s\r"
191C8	8003DDC8	"(NULL)"
191D0	8003DDD0	"%s\r"
191D4	8003DDD4	"(NULL)"
191DC	8003DDDC	"HungUp on Thread %d\r"
191F4	8003DDF4	"%s\r"
191F8	8003DDF8	"(NULL)"
19200	8003DE00	"%s\r"
19204	8003DE04	"(NULL)"
1920C	8003DE0C	"HungUp %s:%d"

		
19710	8003E310	allocation debug messages
199D0	8003E5D0	

	8003E6A0	exception handler offsets
	8003E6C0	pointers to exception handlers
	8003E6E4

19D00	8003E900	forest@srd038J.srd.nintendo.co.jp
19D24	8003E924	compile date	01-02-14 16:37:16
19D40	8003E940	end of block - begins Codeword <-> ROM offset table

+_+

variables within this domain:

80041A90	4	last used PIF command?

80044640	0x40	PIFram buffer
80044680


675720.bin	+80051A80
+-+-+-+-+-+-+-+
 4900	80056380	DEBUG: displays actor name or null
		apparently unlinked
		accepts: A0=p->str-0x170, A1=strlen?
 4974	800563F4
 
	80056494	
		accepts: A0=p->overlay table
	8005652C	
	
 7CC4	80059744	V0=TRUE if [8014A248] isn't furniture (0xxx item)
 7CF4	80059774

 85F0	8005A070	selects one of 5 time retrieval routines for LR clock
		accepts: A0=time value to grab
		returns: V0=variable
		fries: AT,V1,T6 (T7 with option 0)
		options:
		0) 8005A094	returns: V0=0 if a.m., 1 if p.m.
		1) 8005A0B8	returns: V0=# hours - tens place
		2) 8005A0E4	returns: V0=# hours - ones place
		3) 8005A110	returns: V0=# minutes - tens place
		4) 8005A12C	returns: V0=# minutes - ones place
 86D4	8005A154	creates the am/pm in LR clock
	8005A238	loops to construct DL for each component of the LR clock
	8005A2FC
	
 CF34	8005E9B4	1->[80123F04]
 CF48	8005E9C8	3->[80123F04]
 CF5C	8005E9DC	1->[80123F08]
 CF70	8005E9F0	set [80123F08] to 3 if nonzero
 CF24	8005EA14	A0->[80123F0C]
		accepts: A0=???
 CF34	8005EA24	1->[80123F49]
 CF48	8005EA38	1->[80123F4A]
 CF5C	8005EA4C
	
 D420	8005EEA0
 D468	8005EEE8
 
 D5A0	8005F020
 D6BC	8005F13C
 
 DA64	8005F4E4	V0=TRUE if [8014A248] a 3xxx, 4xxx, 6xxx value
	8005F528

135A8	80065028	SW A0,0000 (SP), RETURN	NOP,NOP,NOP,NOP
135C0	80065040	V0=selectmenu base address	[801425C0]
135E4	80065064

136D8	80065158	[SW A1,00A0 (A0)]
	80065164

13718	80065198	reset #select_menu entries
		accepts: A0=base for menu (801425C0); 0->A0+7C
13724	800651A4	copy select_menu entry from buffer to slot
		accepts: A0=base for menu (801425C0), A1=p->str, A2=strlen
		returns: V0=entry# or -1 if invalid
137F8	80065278	copy strings from buffer to entry locations
		accepts: A0=p->menu base, A1=p->str1, A2=strlen1, A3=p->str2, SP+10=strlen2,SP+14=p->str3 or NOP,SP+18=strlen3, SP+1C=p->str4 or NOP,SP+20=strlen4

138C8	80065348	determine longest string in select_menu
		returns: V0=longest string length
1394C	800653CC

13A7C	800654FC	V0=selected selectmenu option; V0=A0+80
		accepts: A0=p->selectmenu base address
13A88	80065508	-1 -> selected selectmenu option; -1->A0+80
		accepts: A0=p->selectmenu base address
13A98	80065518	SP+0=A0, SP+4=A1
		accepts: A0=???, A1=???
13AA8	80065528	converts select_txt ID to codeword and size
		accepts: A0=select_txt ID, A1=p->codeword, A2=p->size
13BE8	80065668	redirects to 8009EC88: A3->SP+24
	8006568C

	80065CA0
14278	80065CF8
		accepts: A0=p->target, A1=strlen, A2=p->???
14310	80065D90	retrieve select menu option text f/ select.txt
		accepts: A0=p->base (unused?), A1=p->target, A2=select_txt ID, A3=p->???
14468	80065EE8	store 1->
		fries: T6=1
	80065EF8	

146B0	80066130	copy selected option from select_txt menu
	80066194
	
	80068A50	retrieve values from player's current collision tile
	80068BB8	
	
	80069580	
	80069680	
	
	8007075C
		accepts: A0=, A1=p->collision tile
	80070880
		accepts: A0=, A1=p->collision tile
	80070950	???; handles tile height
		accepts: A0=, A1=p->collision tile
		uses pointer table @ 80104220
		8007075C or 80070880 if tile & 80000000 set (0:1)
	80070990
	800709A8
	800709E8	
		uses pointer table @ 80104228
	80070A28	
	
	80070D28	???; handles tile type sounds and effects
	80070F58
	80070FBC
	80071064	???; handles tile type sounds and effects
		8007112C	type 1B-3F
		800712A8	types C-15
		800712F0	type 18
		80071300	types 0-B, 16-17, 19-1A
	800713CC
	
272B0	80078D30	V0=TRUE if buttons A0 pressed on controller 1; @8010EF90+14
		accepts: A0=button mask
272F8	80078D78	V0=cur.controller 1 buttons; buttons at @8010EF90+14
2732C	80078DAC	V0=TRUE if buttons A0 held(?) on controller 1; @8010EF90+20
		accepts: A0=button mask
27374	80078DF4	V0=held(?) controller 1 buttons; buttons at @8010EF90+20
273A8	80078E28	V0=cur.controller 1 horizontal stick position; byte from @8010EF90+16
273DC	80078E5C	V0=cur.controller 1 vertical stick position; byte from @8010EF90+17
	80078E90

27640	800790C0	???	at 80079120 creates blank mempak entry

27DB8	80079838	???; tied to the debug gyroid, setting name etc
	uses p->801047A8, p->80137C40, p->80138E44
27E5C	800798DC

299CC	8007B44C	save animation value to specific bank and slot
		accepts: A0=bank offset, A1=slot, A2=animation value
	8007B49C
	
29B40	8007B5C0	set alert bubble text ID# to A0
		accepts: A0=msg_txt ID#
		@80104A70+E4 defines response; if 7,8,9, set text ID#
	8007B5F4
	
29BD0	8007B650	set status; stores A0->address+D8 at 80104A70
		accepts: A0=1 byte
		fries: T6; reduces A0 to 1 byte
29BF0	8007B670	V0=status; loads byte from address+D8 at 80104A70
		returns: V0=1 byte
		fries: T6
29C04	8007B684	neutralize status register; redirect to 8007B650: A0=-1
29C24	8007B6A4	copies status and timestamp to playerdata if not neutral
	8007B724
	
2BE8C	8007D90C	V0=80104F94: 
2BE9C	8007D91C	store A0->80104F94
		returns: V0=value saved (A0)
		fries: AT
	8007D930
	
	8007DB20	???; time-related
	8007DBB0	???; time-related
	
	8007ED70	???; handles day-of-week events
		8007EDBC	Sunday: ???
		8007EDF4	Saturday: ???
		8007EE10	weekdays: ???
		8007EEBC	return
	
	8008033C	V0=p->entered data
		accepts: A0=???, A1=strlen
	800804AC
	
36208	80087C88	returns V0= halfword at 8014A248
		fries: T6
	80087C9C
	
	8008907C	V0=p->current collision tile

3D270	8008ECF0	sets word # A0 at 80106A9C to 0
		accepts: A0 (0-5)
		fries: AT, T6
	8008ED14

3D3FC	8008EE7C	16bit checksum function
		accepts: A0=p->data, A1=#bytes
		returns: V0=16bit checksum for data or 0 if error
3D434	8008EEB4
3D468	8008EEE8	returns 1 if sram+4 = NAFJ
		accepts: A0=p->sram
		returns: V0=1 match
		fries: AT,V1,T6
3D48C	8008EF0C	performs sram verity test, ensuring +4=NAFE0 and 
		accepts: A0=p->sram, A1=short@sram+0x2F68 (30F9)
		returns: V0=1 if passed, 0 if failed
		fries: AT,V1,T6,T7,T8
3D4EC	8008EF6C	passes p->sram + short@sram+0x2F68 (30F9) to sram verity test
		redirects to 8008EF0C
		fries: A0,A1
	8008EF94
	
3D5A0	8008F020	sets six words at A0 to zero
		accepts: A0=p->data
	8008F040
	8008F0A0
	8008F24C
	8008F530
	8008F5FC
	8008F648
	
3DE20	8008F8A0	??? - tied to FLASHram verity tests
		accepts: A0=p->data, A1=initial offset
	8008F938
	
	8008FAE0
	8008FB64
	8008FBEC
	8008FCE8
	8008FDD4
	8008FE74
	8008FF60
	
3E6C0	80090140	returns width of font char
		accepts: A0=char#
		returns: F0=[float]width	T6=width if set only
		fries: AT,T6,F4
3E6F8	80090178	returns address to font char images
		returns: V0=8013A680
	80090188

3E80C	8009028C	compute render width for single character
		accepts: A0=char#, A1=width type (1,0)
		returns: V0=width
		fries: AT,V1,T6,T7,F0,F4
3E84C	800902CC	computes width of characters
		accepts: A0=p->str, A1=strlen, A2=width type (1,0)
		returns: V0=width in thingies
3E8CC	8009034C	determine size of character in string A0
			default for 7F/80 commands is 2; otherwise, real size
		accepts: A0=p->text
		returns: V0=size of character or command
		fries: AT,V0,V1,T6
3E928	800903A8	redirect to 8009034C; get next character from msg_txt bank
		accepts: A0=p->text, A1=offset in text
		fries: A0,A2
3E94C	800903CC	get command type from 7F command table
		accepts: A0=7F command
		returns: V0=matching command type (second value in table)
		fries: V0,T6
3E964	800903E4

3E9F0	80090470	insert "set foreground color" microcode op
		accepts: A0=display list, A1=red, A2=green, A3=blue, SP+10=alpha
3EA38	800904B8	insert "set foreground color" microcode op
		accepts: A0=p->display list, A1=p->colour
	80090504

3EC1C	8009069C	primary font drawing routine: constructs DLs based on selected letter, color, and size.
		accepts: A0=p->DL output, A1=char#, A2=@image offset, A3=@line#, SP+10=@image offset edge, SP+14=@line bottom
		returns: A0=p->DL curpos, A2=p->imgoffset, A3=p->linenum, SP+10=p->imgoffedge, SP+14=p->linebot
3EDC8	80090848	sets table entry at A0 texture size and tile size data
		accepts: A0=p->target, A1=tex.x, A2=tex.y, A3=lrs, SP+0x10=lrt
		fries: T6
3EDFC	8009087C

	80090CC0	text writing routine...
	
3F39C	80090E1C	redirect to text-writting routine 80090CC0
		accepts: A0=, A1=p->text, A2=#chars, A3=[float]xpos, SP+10=ypos, 
			  SP+14=red, SP+18=green, SP+1C=blue, 
			  SP+20=, SP+24=, SP+28=, SP+2C=, 
			  SP+30=[float]xscale?, SP+34=[float]yscale?, SP+38=
3F418	80090E98	print text to screen
		accepts: A0=p->manager, A1=p->text, A2=#chars
			  A3=[float]xpos, SP+10=[float]ypos
			  SP+14=red, SP+18=green, SP+1C=blue, SP+20=alpha
			  SP+24=?, SP+28=?, SP+2C=?, SP+30=[float]?, SP+34=[float]?
3F510	80090F10	???; inserts DL code, maybe for yellow text bubbles?
		accepts: A0=p->DL, A1=mode 
3F5CC	8009104C	redirect to 800E0244
		saves A0->SP+18, A1->SP+1C; does not recall
3F5F4	80091074	redirect to 8009040C; sets A1=1
3F614	80091094

3F6BC	8009113C	prints font to dialog boxes, calling 8009069C
		accepts: A0=, A1=, A2=, A3=, SP+10=, SP+14=char.width, SP+18=, SP+1C=, SP+20
3F768	800911E8	prints font to bubbles, calling 8009069C
		accepts: A0=p->???, A1=p->???, A2=, A3=p->(float) ???, SP+10=p->(float) display size, SP+14=char.width, SP+18=???
3F954	800913D4	manages the countdown for the 7F50 colour override command
		accepts: A0=, A1=, A2=p->display list
	80091470
	
3FA7C	800914FC	interpret 7F50 command for display
		accepts: A0=p->print controller, A1=p->display list
3FAD4	80091554	interpret 7F54 command for display
		accepts: A0=p->print controller, A1=p->display list
3FB24	800915A4	V0=800914FC if A0 is type 7F50: colour #bytes
			V0=80091554 if A0 is type 7F54: char size
		accepts: A0=7F command type
3FB58	800915D8	sets print controller+48 data table, which includes the width type flag
		accepts: A0=p->print controller+48, A1=, A2=char size (1 normal, etc. 7Fcmds), A3=flags, SP+10=, SP+14=, SP+18=, SP+1C=, SP+20=
3FCFC	8009167C	??? - apparently draws font for messages
		
3FD48	800917C8	text on text entry routine, probably everything from dials to screen to what you type in
		grabs width of characters in screen and renders them - handy
		calls: 8009028C (1); recalls the A1 from 8014774C+5 &0x1
3FE28	800918A8	redirects to 800917C8; if handler's control word(+5) 0002 set, use 800917C8, not 8009167C
		calls: 800917C8 or 8009167C
		accepts: A0=p->text handler (80145080)
3FE68	800918E8	F0=float #A0 at 80106D24
		accepts: A0=entry#
3FE80	80091900	set volume for speech
		accepts: A0=p->print controller, A1=(unused)
3FEBC	8009193C	play sound
		accepts: A0=p->print controller, A1=(unused)
3FF00	80091980	set font size
		accepts: A0=p->print controller, A1=(unused)
3FF50	800919D0	V0=80091900 if A0 is type 7F52: set volume
			V0=8009193C if A0 is type 7F53: play sound
			V0=80091980 if A0 is type 7F5A: font size
		accepts: A0=7F command type
	80091A18
	
40180	80091C00
40218	80091C98	???	only caller of 800903CC
	80091DFC
	
	80092538
40BCC	8009264C	convert numeral to string value
		accepts: A0=target, A1=#, A2=max strlen, A3=fill type, SP+10=mode
			modes:
				0) normal numerical write (fill left with spaces)
				1) zero extended
			fill types: (mode 0 only)
				0) max strlen treated as min width (align right)
				1) display numeral without spacing (align left)
		returns: V0=strlen
40E40	800928C0	initialize ???: saves 0->80137934, 40A00000->80137938
		fries: AT,V0,F4
	800928E8
	
41290	80092D10	copy A2 bytes from string A1 to string variable slot A0
		accepts: A0=slot 0-19, A1=p->text, A2=strlen
41394	80092E14
41400	80092E80
41544	80092FC4	inserts text from slot SP+10 into mail message
		accepts: A0=p->text, A1=, A2=offset in text, A3=, SP+10=slot#, SP+14=
	800930B0	7F24	calls 80092FC4: SP+10=0, SP+14=[SP+10]
	800930D8	7F25	calls 80092FC4: SP+10=1, SP+14=[SP+10]
	80093104	7F26	calls 80092FC4: SP+10=2, SP+14=[SP+10]
	80093130	7F27	calls 80092FC4: SP+10=3, SP+14=[SP+10]
	8009315C	7F28	calls 80092FC4: SP+10=4, SP+14=[SP+10]
	80093188	7F29	calls 80092FC4: SP+10=5, SP+14=[SP+10]
	800931B4	7F2A	calls 80092FC4: SP+10=6, SP+14=[SP+10]
	800931E0	7F2B	calls 80092FC4: SP+10=7, SP+14=[SP+10]
	8009320C	7F2C	calls 80092FC4: SP+10=8, SP+14=[SP+10]
	80093238	7F2D	calls 80092FC4: SP+10=9, SP+14=[SP+10]
	80093264	7F36	calls 80092FC4: SP+10=A, SP+14=[SP+10]
	80093290	7F37	calls 80092FC4: SP+10=B, SP+14=[SP+10]
	800932BC	7F38	calls 80092FC4: SP+10=C, SP+14=[SP+10]
	800932E8	7F39	calls 80092FC4: SP+10=D, SP+14=[SP+10]
	80093314	7F3A	calls 80092FC4: SP+10=E, SP+14=[SP+10]
	80093340	7F3B	calls 80092FC4: SP+10=F, SP+14=[SP+10]
	8009336C	7F3C	calls 80092FC4: SP+10=10, SP+14=[SP+10]
	80093398	7F3D	calls 80092FC4: SP+10=11, SP+14=[SP+10]
	800933C4	7F3E	calls 80092FC4: SP+10=12, SP+14=[SP+10]
	800933F0	7F3F	calls 80092FC4: SP+10=13, SP+14=[SP+10]
4199C	8009341C	handles 7F slot insert types in mail messages and other text banks
		accepts: A0=p->text, A1=size, A2=, A3=, SP+10=
419F8	80093478	loads and expands mail messages (ie. snowman)
		accepts: A0=p->text, A1=size, A2=max size, A3=fill mode
		note: will loop endlessly if a mail message exceeds buffer
	80093520	??; similiar to 80093478, used for superscripts
41B78	800935F8	converts super_txt ID to codeword and size
		accepts: A0=super_txt ID, A1=p->codeword, A2=p->size
41CB8	80093738	converts ps_txt ID to codeword and size
		accepts: A0=super_txt ID, A1=p->codeword, A2=p->size
41DF8	80093878	converts mail_txt ID to codeword and size
		accepts: A0=mail_txt ID, A1=p->codeword, A2=p->size
41F38	800939B8
	
420A8	80093B28	loads superscript text for messages f/ super.txt
		accepts: A0=p->target, A1=max strlen, A2=, A3=super_txt ID#
42218	80093C98	loads postscript text for messages f/ PS.txt
		accepts: A0=p->target, A1=max strlen, A2=ps_txt ID#
42328	80093DA8	loads mail text for messages f/ mail.txt
		accepts: A0=p->target, A1=text ID
42484	80093F04	loads text for mail message
		accepts: A0=p->buffer, A1=buffer size, A2=p->postscript target, A3=p->mail target, SP+10=text ID
424D4	80093F54	loads text for mail message
		accepts: A0=p->superscript target, A1=super strlen, A2=, A3=p->postscript target, SP+10=ps strlen, SP+14=p->mail target, SP+18=txtID#
42514	80093F94	retrieve codeword and strlen for multibank text entry (D1A000)
		accepts: A0=p->multi_txt struct
42628	800940A8	loads text for multi-block string f/ superz.txt, maila-c.txt, or psz.txt
		accepts: A0=p->multi_txt struct
			struct:
			0x0	4	bank#	(0=superz, 1=maila, 2=mailb, 3=mailc, 4=psz)
			0x4	4	text ID#
			0x8	4	p->target
			0xC	4	max strlen
			0x10	4	RESERVED for codeword
			0x14	4	RESERVED for strlen
42730	800941B0	???; related to superz
42820	800942A0	???; related to maila+mailb+mailc
42980	80094400	???; related to psz
	800944B8
42AA0	80094520	at one point sets the default 'I'm not home' message (0x55C string)
	80094690
	
43484	80094F04	Redirect to 800998C0, forcing string size=6; used to copy town name
		accepts: A0=p->target, A1=p->source, A2 set to 6
434A4	80094F24	???	pulls up 0x1E4 in string_txt, which is NULL...
	80094F84

435CC	8009504C	pulls NPC name, sets NULL catchphrase, copies to 2x string slot
		accepts: A0=p->target, A1=slot#
43658	800950D8	returns V0=80139E00
	800950E8	

44C90	80096710	redirect to ROM data retrieval: strlen 0xA
		accepts: A0=p->target, A1=codeword, A2=strlen
		calls 80026E10: A2=0xA, A3=801170B0, SP+0x10=0x55
		len=10, debug string="../m_item_name.c"
44CC0	80096740	copy item A1's name from ROM to A0
		accepts: A0=p->target, A1=item ID# (1xxx or 2xxx)
	80096860
	
	800996CC	
		accepts: A0=
	
47E40	800998C0	copy routine for NPC name strings
		accepts: A0=p->target, A1=p->source, A2=strlen
47EAC	8009992C	memset	create fill string
		accepts: A0=p->buffer, A1=strlen, A2=fill character
		fries: A0, V0, V1, A3, SP+8
	80099980	TRUE if A2 bytes of A1 match A0
		accepts: A0=p->data.1, A1=p->data.2, A2=strlen
	80099A54
	
	80099C18
		accepts: A0=p->???, A1=(float)???, A2=(float)???
	80099C84

48568	80099FE8	generates a random number
		accepts: A0=added to value, A1=multiplied by value (0-this)
		returns: V0=#
	8009A03C
	
	8009A0C4	convert 3 shorts at A1 into floats stored at A0
		accepts: A0=p->target (0xC), A1=p->source (0x6)
	8009A108
	
491CC	8009AC4C	copy 4 bytes from source to target
		accepts: A0=p->target, A1=p->source
		fries: T6,T7,T8,T9
491F4	8009AC74	returns V0=0; used by C-724950, C-8574E0
49200	8009AC80	A0->SP+0, A1->SP+4
49210	8009AC90	

49328	8009ADA8	convert 0X- offset type to a rdram address
		accepts: A0=0X-offset
		returns: V0=rdram address
		fries: AT,T0,T6,T7,T8,T9
49360	8009ADE0	convert 0X- offset type to a rdram address - returns V0=A0 if type 0
		accepts: A0=0X-offset
		returns: V0=rdram address
		fries: AT,T0,T6,T7,T8,T9
493A8	8009AE28	converts literal offset to pointer (appends 80000000 to non-NULL offset)
		accepts: A0=offset
		returns: V0=pointer or NULL if A0=0
		fries: AT
493C4	8009AE44	duplicate of 8009AE28
	8009AE60
	
4A540	8009BFC0	calls 8002CE30: A0=80141FA0, A1=[A0 f/caller]
4A568	8009BFE8	calls 8002CE70: A0=80141FA0, A1=[A0 f/caller]
	8009C010
4A5C0	8009C040	calls 8002D0F4: A0=80141FA0, A1=[A0 f/caller]
		accepts: A0=???
	8009C068
	8009C0C0
4A678	8009C0F8	calls 8002D784: A0=80141FA0
	8009C11C
	8009C16C
4A71C	8009C19C	calls 8002CD20: A0=80141FA0
4A740	8009C1C0	removes trailing characters from string
		accepts: A0=p->string, A1=strlen, A2=search character
		returns: V0=new strlen (copied from A1)
		fries: V0,V1,A0,A1,A3,T0,T6,T7,T8,T9	;reduces A2 to 1 byte
4A804	8009C284	V0=true strlen of A1, size A2, disregarding A3.  Status FALSE if empty string
		accepts: A0=p->status, A1=p->source, A2=max strlen, A3=search character
	8009C2D8
	
	8009C414
	8009C438	copy 0x11 bytes from A1 to A0; calls 800B79E0
		accepts: A0=p->target, A1=p->source
	8009C45C	calls 8009C438: A0+=12
		accepts: A0=p->target, A1=p->source
	8009C480	redirect to 8009C438
	8009C4A0
	8009C4C8
	8009C4F4
	8009C534
	
	8009C608
4ABFC	8009C67C	copy 0xA4 bytes from A1 to A0; calls 800998C0: A2=strlen 0xA4
		accepts: A0=p->target, A1=p->source
	8009C69C
	8009C6EC	copy 0x1C bytes from A1 to A0; calls 800998C0: A2=strlen 0x1C
		accepts: A0=p->target, A1=p->source
	8009C70C
	8009C780
	8009C80C
	8009C89C
	8009C8C0
	8009C900

4B770	8009D1F0	returns V0=80142410: text controller
	8009D200
	
4B888	8009D308	???
		calls 800902CC with A2=0
	8009D3B4
	8009D3E4
	
4BC50	8009D6D0	copy A3 bytes from string A2 to slot A1 of table at A0
		accepts: A0=p->text controller, A1=slot#, A2=p->text, A3=size
4BDA0	8009D820	???	sets values at 80142690-92, used when doing character name recall
		accepts: A0=p->text controller, A1=slot#, A2=p->text, A3=size, SP+10=???
4BE0C	8009D88C	???	probably copies A3 bytes of string A2 to slot A1 of controller A0; only use slots 5-A
		accepts: A0=p->text controller, A1=slot#, A2=p->text, A3=strlen
	8009D9A4
	
4C124	8009DBA4	set text ID A1 as next jump for text controller A0; A1->A0+2C4
		accepts: A0=p->text controller, A1=msg_txt ID
	8009DBB0
4C160	8009DBE0	returns 1 if value at 80136F34 > 0
		returns: V0=TRUE/FALSE
		fries: V1
4C184	8009DC04	redirect to 800903A8; sizeof character in loaded text bank
		accepts: A0=p->text controller [80142410], A1=current offset in bank
		returns: V0=size of char or command at location A1 in text A0
	8009DC2C
	
4C3A8	8009DE28	convert wait value in 7F03 command to float
		accepts: A0=p->txt,A1=offset to text
		returns: F0=wait value
		fries: AT,V0,V1,F4
4C3EC	8009DE6C	reroute wait value conversion to 8009DE28
		accepts: A0=txt controller,A1=offset in text
		fries: A0,A2	[jump: AT,V0,V1,F4]
4C414	8009DE94	copy color from 7F05 command to target
		accepts: A0=p->txt,A1=offset in txt,A2=p->red,A3=p->green,SP+0x10=p->blue
		fries: AT,V0,V1,T6,T7,T8,T9
4C468	8009DEE8	reroutes color command to 8009DE94
		accepts: A0=txt controller,A1=offset in txt,A2=p->red,A3=p->green, SP+0x10=p->blue
		fries: A0,T6,T7 [jump: AT,V0,V1,T8,T9]
4C49C	8009DF1C
		accepts: A0=p->text, A1=offset in text,A2=unknown value target(SP+24),A3=animation value target(SP+22)
		returns: V0=1 if valid 7F08-0C command
			saves com+2 -> A2, animation value to A3
4C510	8009DF90	redirect to 8009DF1C
		saves p->text handler to SP+18, sets A0=p->text
		calls: 8009DF1C
4C53C	8009DFBC	V0=command+2 if 7F51 command
		accepts: A0=p->msg_txt, A1=offset in txt
		fries: AT,V0,V1,T6,T7
4C574	8009DFF4	calls 8009DFBC: A0=p->msg_txt
		accepts: A0=p->text controller, A1=offset in txt
		fries: A0,A2	[jump: AT,V0,V1,T6,T7]
	8009DE1C	
	
	8009E334	
4C8F4	8009E374	set float at txtbank controller+0x294
		accepts: A0=txt bank controller,A1=float
		fries: F12
4C908	8009E388	converts msg_txt ID to codeword and size
		accepts: A0=msg_txt ID,A1=p->codeword,A2=p->strlen
		returns: V0=text offset in table, V1=length; codeword+len->respective input addresses
4CA48	8009E4C8

4CAD8	8009E558	retrieve text from msg.txt text bank using index value
		accepts: A0=p->text controller, A1=msg_txt ID#, A2=unknown
4CBD8	8009E658	replace and display msg_txt at text controller A0 using ID A1
		accepts: A0=p->text controller, A1=msg_txt ID#
4CC38	8009E6B8	save 0->txtbank controller+0x2D4
		accepts: A0=p->txt bank controller
4CC44	8009E6C4	save 1->txtbank controller+0x2D4
		accepts: A0=p->txt bank controller
	8009E6D4

4CE50	8009E8D0	right-align text; omits trailing spaces
		accepts: A0=p->string, A1=string length
		returns: V0=strlen omitting trailing spaces
		fries: A0,V0,V1,T6
	8009E908
	
4CEF0	8009E970	V0=TRUE if A0+2B4=0
		accepts: A0=p->text controller
4CF10	8009E990	
		accepts: A0=p->text controller
4CF24	8009E9A4	1->A0+2C8
		accepts: A0=p->text controller
4CF34	8009E9B4	0->A0+2C8
		accepts: A0=p->text controller
4CF40	8009E9C0	load saved msg_txt; 1->A0+2CC
		accepts: A0=p->text controller
4CF50	8009E9D0	do not load saved msg_txt; 0->A0+2CC
		accepts: A0=p->text controller
4CF5C	8009E9DC	V0=A0+2D0
		accepts: A0=p->text controller
4CF68	8009E9E8	1->A0+2D0
		accepts: A0=p->text controller
4CF78	8009E9F8	0->A0+2D0
		accepts: A0=p->text controller
4CF84	8009EA04	set 0x40 text controller flag; A0+28C |= 40
		accepts: A0=p->text controller
4CF98	8009EA18	V0=TRUE if 0x80 text controller flag set; A0+28C
		accepts: A0=p->text controller
4CFAC	8009EA2C	extend txt bank for a newly-created string (ie. hours 7F com.); copies contents into extension but does not copy new string in!
		accepts: A0=p->text bank, A1=cur text pos.+size of created string, A2=cur text pos.+command size, A3=size of text bank, SP+10=TRUE fills with spaces when reducing bank size
		returns: V0=new size of text bank
4D0C4	8009EB44	copy source to destination - used by text insertion routines
		accepts: A0=p->copy location,A1=source location, A2=strlen
4D130	8009EBB0
		accepts: A0=p->target, A1=p->text offset, A2=???, A3=p->text controller
4D208	8009EC88
4D294	8009ED14	replace microcode text command with speaker's name
		accepts: A0=p->???, A1=p->msg_txt, A2=text offset, A3=size of msg_txt
4D33C	8009EDBC	replace microcode text command with catchphrase
		accepts: A0=p->???, A1=p->msg_txt, A2=text offset, A3=size of msg_txt
4D3F8	8009EE78	7F1D insert string: year
4D480	8009EF00	7F1E insert string: month
4D508	8009EF88	7F1F insert string: day of week
4D590	8009F010	7F20 insert string: day of month
4D618	8009F098	7F21 insert string: hours
4D6A0	8009F120	7F22 insert string: minutes
4D728	8009F1A8	7F23 insert string: seconds
4D7B0	8009F230	inserts string[10] from bank of 20 to destination
		accepts: A0=p->txt bank, A1=entry#(0-20), A2=p->msg_txt, A3=curpos msg_txt
		calls: 800903A8, 8009E8D0, 8009EA2C, 8009EB44
4D86C	8009F2EC	inserts 7F50 colour command at A0+A1 to colourize text A3, in colour SP+10
		accepts: A0=p->target, A1=p->cur.position, A2=max strlen, A3=p->source, SP+10=colour ID#
4D928	8009F3A8	7F2E insert string: last sel.option
4D9A8	8009F428	7F2F insert string: town
4DA8C	8009F50C
4DB34	8009F5B4	inserts text from entries starting at text controller + 100 (80142210)
		accepts: A0=p->text controller, A1=entry#(0-4), A2=p->msg_txt, A3=curpos in msg_txt, SP+10=sizeof msg_txt
4DBF0	8009F670	inserts text from text controller (A0) + 132, offset A1 to target A2, offset A3, size SP+10
		accepts: A0=p->text controller, A1=entry#(0), A2=p->msg_txt, A3=curpos, SP+10=sizeof msg_txt
	
4DCB0	8009F730	returns value in 80107B90 for char or -1
		accepts: A0=char
		returns: V0=value or -1 if command type
		fries: AT
	8009F75C
	
	8009FCB8
	
	8009FD40
4E300	8009FD80	unset flag 0x10 at controller+28C
		accepts: A0=p->text controller
	8009FDA0
	8009FDF8
4E3CC	8009FE4C	redirect to 800A3190
4E3EC	8009FE6C	calls 8009E6F8: A0=A1, SP+18=A0
	8009FE90
	8009FF24
	8009FF68
4E530	8009FFB0	
		accepts: A0=p->text controller, A1=
	800A0110
	
4EAC8	800A054C	V0=TRUE if A or B pressed; quick-advance must be enabled and not currently used
		accepts: A0=p->text controller
4EB28	800A05A8	catch 7F commands in text
		accepts: A0=p->txt bank controller,A1=offset in bank
		returns: V0=1 if 7F, V0=0 by default
4EB58	800A05D8	7F00 command: close window
4EB94	800A0614	7F01 command: open window
4EBD0	800A0650	7F02 command: clear window
4EC2C	800A06AC	7F03 command: delay
4ECF0	800A0770	7F04 command: pause
4ED68	800A07E8	7F05 command: font color
4EDE4	800A0864	7F06 command: 
4EE30	800A08B0	7F07 command: 
4EE78	800A08F8	processes 7F08-7F0C
4EEE4	800A0964	7F08 command: 
4EF04	800A0984	7F09 command: emote
4EF24	800A09A4	7F0A command: 
4EF44	800A09C4	7F0B command: 
4EF64	800A09E4	7F0C command: 
4EF84	800A0A04	7F0D command: 
4EFE0	800A0A60	processes 7F0E-7F12
	800A0B14	7F0E command: 
	800A0B34	7F0F command: 
	800A0B54	7F10 command: 
	800A0B74	7F11 command: 
	800A0B94	7F12 command: 
4F134	800A0BB4	processes response command types 7F13-7F15
		accepts: A0=,A1=,A2=#responses
	800A0D94	7F13 command: random response 2
	800A0DB4	7F14 command: random response 3
	800A0DD4	7F15 command: random response 4
4F374	800A0DF4	processes menu command types 7F16-7F18
		accepts: A0=,A1=,A2=#options
	800A0FCC	7F16 command: menu 2
	800A0FEC	7F17 command: menu 3
	800A100C	7F18 command: menu 4
	800A102C	7F19 command: 
	800A1078	7F1A command: 
	800A10D8	7F1B command: 
	800A1124	7F1C command: 
4F6F0	800A1170	7F1D command: year
4F734	800A11B4	7F1E command: month
4F778	800A11F8	7F1F command: day of week
4F7BC	800A123C	7F20 command: day of month
4F800	800A1280	7F21 command: hours
4F844	800A12C4	7F22 command: minutes
4F888	800A1308	7F23 command: seconds
4F8CC	800A134C	insert string from table - reroute to 8009F230
		accepts: A0=text bank controller,A1=p->curpos in text bank,A2=entry#
4F914	800A1394	processes 7F24-7F3F
	800A141C	7F24 command: name, in game
	800A1444	7F25 command: 
	800A1468	7F26 command: random actor name
	800A148C	7F27 command: random food
	800A14B4	7F28 command: random game, but right now breaks?
	800A14DC	7F29 command: random game?
	800A1500	7F2A command: random insect?
	800A1528	7F2B command: random fish?
	800A1550	7F2C command: random +likeness (good, cool)
	800A1578	7F2D command: random -likeness (unsure, above seemed +, this -)?
	800A15A0	7F36 command: ?random music?
	800A15C8	7F37 command: ?random flavor?
	800A15F0	7F38 command: ?random +aesthetic?
	800A1618	7F39 command: ?random -aesthetic?
	800A1640	7F3A command: ?foreign town's name?
	800A1668	7F3B command: ?town's name?
	800A1690	7F3C command: 
	800A16B8	7F3D command: 
	800A16E0	7F3E command: 
	800A1708	7F3F command: 
	800A1730	7F2E command: 
	800A1774	7F2F command: 
	800A17B8	7F30 command: 
4FD7C	800A17FC	processes 7F31-7F35
		accepts: A0=p->text controller, A1=cur.msg_txt pos, A2=entry#(0-4)
	800A1844	7F31 command: 
	800A186C	7F32 command: 
	800A1894	7F33 command: 
	800A18BC	7F34 command: 
	800A18E4	7F35 command: 
4FE8C	800A190C	insert text from text controller (A0) + 132, offset A2 to msg_txt, offset A1; processes 7F40
		accepts: A0=p->text controller, A1=text offset, A2=offset(?)
	800A1954	7F40 command: 
4FEFC	800A197C	processes 7F41-7F4A
	800A19C4	7F41 command: 
	800A19E4	7F42 command: 
	800A1A04	7F43 command: 
	800A1A24	7F44 command: 
	800A1A44	7F45 command: 
	800A1A64	7F46 command: 
	800A1A84	7F47 command: 
	800A1AA4	7F48 command: 
	800A1AC4	7F49 command: 
	800A1AE4	7F4A command: 
50084	800A1B04	process 7F4B-7F4F
	800A1B4C	7F4B command: 
	800A1B6C	7F4C command: 
	800A1B8C	7F4D command: 
	800A1BAC	7F4E command: 
	800A1BCC	7F4F command: 
5016C	800A1BEC	7F50 command: font color # characters
501A4	800A1C24	7F51 command: 
50224	800A1CA4	7F52 command: 
5025C	800A1CDC	7F53 command: 
50294	800A1D14	7F54 command: 
502CC	800A1D4C	7F55 command: 
50350	800A1DD0	7F56 command: 
503B8	800A1E38	7F57 command: 
50420	800A1EA0	7F58 command: 
5049C	800A1F1C	7F59 command: sound effect
504FC	800A1F7C	7F5A command: font size
50534	800A1FB4	7F5B command: 
50580	800A2000	7F5C command: 
505CC	800A204C	7F5D command: 
50618	800A2098	7F5E command: 
50660	800A20E0	7F5F command: 
506D0	800A2150	7F60 command: 
50740	800A21C0	handle 7F commands embedded in text
		accepts: A0=text bank controller,A1=p->curpos in text bank
	800A223C

51030	800A2AB0	redirect to 800E0244: use previous matrix
	800A2AD0
	
511CC	800A2C4C	draws the blue advance arrow to the screen
		accepts: A0=p->text controller,A1=p->manager[80229050], A2=?[1]
		800A2C98 sets x position
		800A2CAC sets y position
51264	800A2CE4	constructs the balloons for normal character text
		Also places speakers name into the upper balloon.
		accepts: A0=p->text controller[80142410],A1=p->manager[80229050],A2=mode? (1 causes a draw to screen)
		returns: V0=p->last command in DL
	800A2EAC
51710	800A3190
		accepts: A0=p->text controller
		uses pointer table at 8010AE00; 8 entries
51758	800A31D8
		accepts: A0=p->text controller
		uses pointer table at 8010AE20; 8 entries
	800A3220
	
	800A339C
51958	800A33D8	calls 800A3220: A0=p->text controller, A1=[A0]
		accepts: A0=???
51980	800A3400	calls 8002F4C0: A1=1
	800A3420
	
53C4C	800A56CC	V0=fish text ID from fish# A0
		accepts: A0=fish#
	800A56F0
	
	800A5CB0	V0=number of valid message board messages
	800A5D30
	
543D8	800A5E58	set variable slots: 1: actor A0, 2: item A1, 3: number A3, 4: number A2
		accepts: A0=actor ID#, A1=item ID#, A2=number 0-9, A3=number 0-9
	800A5F08
	
	
54978	800A63F8	pulls Nook's store name (0x558 string_txt)
	800A6450
	
54F48	800A69C8	V0=TRUE if short at A0 isn't an actor ID
		accepts: A0=p->actor struct
	800A6A04
	
	800A7AEC
		accepts: A0=p->actor ID
	
57EAC	800A992C	sets random ??? item ID# in A0
		accepts: A0=p->target
57F38	800A99B8	
		accepts: A0=, A1=p->string, A2=actor ID#
	
583FC	800A9E7C	pulls name? from save slot(?)
		accepts: A0=p->thingy [80276410]
		returns: V0=p->string
	
58448	800A9EC8	NPC catchphrase
		accepts: A0=p->actor something
	800A9F9C
	
58798	800AA218	set actor ID A1's character attributes (catchphrase, outfit, etc.)
		accepts: A0=p->target, A1=npc_txt ID#, A2=personality?, A3=p->NPC response entry
5881C	800AA29C	retrieve and set catchphrase at A0 from table A2 for NPC ID# A1
		accepts: A0=p->target, A1=npc_txt ID#, A2=p->NPC response table
58878	800AA2F8	???
		accepts: A0=npc_txt ID#
	800AA35C
	800AA3A4
	
58A9C	800AA51C	NPC clothes; data assigned to E03000,E0D000	0x6 1st,1? second
58D10	800AA790	NPC data assigned to E03000	0x6 each
	800AA8C4
	
596B4	800AB134	NPC data assigned to E02000	0x8? each
	800AB3A0
	
5A094	800ABB14	returns V0=80143388
	800ABB24
	
5B1B8	800ACC38	copy NPC# A1's name to A0	8, then 0x6 each
		accepts: A0=p->target, A1=actor#
5B22C	800ACCAC	retrieve actor's name	(default: 8010B810)
		accepts: A0=p->target, A1=actor ID (Exxx)
5B298	800ACD18	retrieve actor's name by ID	(default: 8010B810)
		accepts: A0=p->target, A1=p->actor ID
5B2F4	800ACD74	NPC name copier for those from string.txt	(default: 8010B810)
		accepts: A0=p->target, A1=string to retrieve (Dxxx), 
5B378	800ACDF8	retrieve current actor's name	(default: 8010B810)
		accepts: A0=p->target, A1=???
	800ACE90
	
5BE44	800AD8C4	NPC data assigned to E03000	0x6 each
	800AD954
	
5D49C	800AEF1C	V0=TRUE if short at A0 isn't an actor ID;	returns FALSE if A0 NULL
		accepts: A0=p->actor struct
	800AEF4C
	
60108	800B1B88	player data from B68000,B88000
60204	800B1C84	V0=A0+1C90: p->overlay table
		accepts: A0=p->manager
	800B1C90
	800B1CBC
	
61C60	800B36E0	save animation A0 to slot 8 of bank 0
		accepts: A0=animation#
61C8C	800B370C	calls 8007B49C: A0=0, A1=8
61CB0	800B3730	save animation A0 to slot 9 of bank 0
		accepts: A0=animation#
61CDC	800B375C	calls 8007B49C: A0=0, A1=9
	800B3780
	800B37AC
	800B3864
	
	800B6AC8
65114	800B6B94
		accepts: A0=p->buffer, A1=???, A2=item ID#
65194	800B6C14
		accepts: A0=, A1=, A2=p->struct
	800B6C88
	
65D24	800B77A4	NPC name string copy redirect to 800998C0
		accepts: A0=p->target, A1=p->source, A2 set to 6
	
	800B79E0	copy 0x10 bytes from A1 to A0; calls 800998C0: A2=0x10
		accepts: A0=p->target, A1=p->source
	800B7A00
	
	800B8A88
	800B8B08
	800B8B8C

68BE0	800BA660	blank entry A0 of size 0xC, setting first byte to C0
		accepts: A0=p->entry
	800BA690
	
	800BB4B0
	800BB5DC
	
69C20	800BB6A0	copy name of item A0 to slot A1; must be slot 5-A
		accepts: A0=item#, A1=slot#
69C70	800BB6F0	???	quest recall, used to write text variables (2x slots)
		accepts: A0=item#, A1=slot#
	800BB740
69DEC	800BB86C
		accepts: A0=, A1=, A2=actor ID#, A3=, SP+10=item ID#
	800BB990
	
	800BE1D4	
		accepts: A0=, A1=, A2=, A3=, SP+10=, SP+14=, SP+18=, SP+1C=, SP+20=, SP+24=
	800BE27C	
	
6D68C	800BF10C	muddles out the different item types
	800BF230
	
71750	800C31D0	???	copies default away message from 0x55C string
	800C327C
	
723B0	800C3E30	converts string_txt ID to codeword and size
		accepts: A0=string_txt ID, A1=p->codeword, A2=p->size
		returns: SP+A0=strlen-1, SP+A4=codeword for entry
		incidental returns: V0=offset from base address T8, V1=strlen, T9=codeword for entry
724F0	800C3F70	retrieve string from string.txt
		accepts: A0=p->target, A1=max strlen, A2=str# to retrieve
		returns: V0=strlen, SP+0=p->string
72604	800C4084	7F1D year string constructor
72678	800C40F8	7F1E month string constructor
726E8	800C4168	7F1F day of week string constructor
72738	800C41B8	7F20 day of month string constructor
727A8	800C4228	7F21 hours string constructor
72868	800C42E8	7F22 minutes string constructor
728D0	800C4350	7F23 seconds string constructor
72938	800C43B8
729A0	800C4420	V0=TRUE if @8010DCE8 = 8010DD08
729C0	800C4440
	
7330C	800C4D8C	calls 800C4DD8: SP+10=0, SP+14=0 (NULL item & text)
		accepts: A0=p->struct, A1=, A2=, A3=
73330	800C4DB0	calls 800C4DD8: SP+14=0 (NULL item)
		accepts: A0=, A1=, A2=, A3=, SP+10=p->text
73358	800C4DD8	set A0 values
		A0+4=A1, A0+10=A2, A0+14=A3, A0+18=SP+10, A0+1C=SP+14
		accepts: A0=p->struct, A1=, A2=, A3=, SP+10=p->text(?), SP+14=item ID
	800C4DFC
	
733D8	800C4E58	interior interface
		accepts: A0=p->manager [80229050]
	800C50C4
	
738A8	800C5328	
		accepts: A0=[8022AD0C] p->base for typed message count
		gets +0xC (count), converts to offset, adds to 8010DD24
	800C535C
	
77590	800C9010	stores time from sram to clock setting
77608	800C9088	saves 1->8010EDD0
		fries: AT,T6
7761C	800C909C	returns word at 8010EDA4, -1
		returns: V0=V1-1,V1=word at 8010EDA4
		fries: V0,V1
7763C	800C90BC	loads word at 8010EDA0, returns 1 if < 0x6E5
		returns: V0=1 if <0x6E5
		fries: AT,V1,T6
77664	800C90E4	NOP,NOP,NOP
	800C90F0
	
787B0	800CA230	stores 0->8010EEE4
		fries: AT
	800CA240
	
78BBC	800CA63C	advance clock time
	800CA8A0
	
7A500	800CBF80	initialize onhover text bubble entry
7A53C	800CBFBC	generate text bubble
		accepts: A0=p->manager
	800CC064	text bubble type 0
	800CC094	text bubble type 1,2
	800CC0C0	text bubble type 3
	800CC120	text bubble type 4
	800CC1AC	generic code for above text bubble constructors
7A96C	800CC3EC	display text bubbles sized to text width
7AF44	800CC9C4	blanks 8 bytes at 801446C8; calls 8002F4C0: A0=801446C8, A1=8
	800CC9EC
	
7BBC0	800CD640	copies NAFJ01 to target, though generalized
		accepts: A0=p->source, A1=p->target "01", A2=p->target "NAFJ"
	800CD68C
	
7C160	800CDBE0	returns V0= toggle at 8010EF60: 
	800CDBF0	
	
8001C	800D1A9C	redirect to 800F8D5C;
		reduces A0 to 2 bytes only, which 800F8D5C already does anyway
	800D1AC4
	
80570	800D1FF0	redirect to 800FA92C
	800D2010
	
81C0C	800D368C	V0=p->menu pointer correction; V0=A0+C
		accepts: A0=p->manager	[80229050]
81C18	800D3698	V0=size(?) of file; A0+10
		accepts: A0=p->???
80C24	800D26A4	V0=TRUE when binary finished loading; A0+9F
		accepts: A0=p->???
	
	800D36B0
	
82104	800D3B84	selects menu to load
		accepts: A0=p->manager	[80229050]
			80802A2C->80106E20: 
			80801A34->80106E50: Debug
			808032F8->80106E80: Gameplay
			8080486C->80106EB0: at load...
			80804B6C->80106EE0: 
			80805968->80106F10: Nintendo
			80829014->80106F40: 
			80829DC0->80106F70: 
			8082DF6C->80106FA0: 
			8085BA28->80106FD0: 
	800D3C94
	
	800D3E14	calls 8002DB20: A0+=68, A1=0, A2=1
	800D3E40
	
	800D4DC0	??? - untoggles values in RTC controller
	800D4E20	read date from RTC, storing in A0
		accepts: A0=p->date
	800D4E94	retrieve and compare RTC minutes+seconds to that at 80145628, then proceed to always simply return the error code 0.o
	800D4F18	read and store minutes & seconds from RTC to 80145628, 1->8010EFD4
	800D4F6C	set RTC component 1 settings to A0
		accepts: A0=p->component 1 settings
	800D4FB8	read RTC component 1 settings to A0
		accepts: A0=p->component 1 settings
	800D5004	computes day of week and writes time settings A0 to RTC
		accepts: A0=p->time
	800D5090	copy time from RTC to A0
		accepts: A0=p->time
	800D5104	V0=day of month
		accepts: A0=year, A1=month
	800D5164
	800D51E0	V0=TRUE if any of components A2 set equal in message controllers A0 and A1
		accepts: A0=p->message.control, A1=p->sample.control, A2=mask
	800D52C0
	800D53A4	copy and compare RTC time A0 to A1; calls 800D5090, 800D51E0
		accepts: A0=p->target, A1=p->cur.time
	800D53DC
	800D5414
	800D5480
83A5C	800D54DC	I believe this computes the day of week from date
		returns: V0=number of days: %7 to create day of week
	800D56B8	increment #years at A0 by A1
		accepts: A0=p->time, A1=increment
	800D56CC	increment #months at A0 by A1, advancing #years when necessary
		accepts: A0=p->time, A1=increment
	800D572C	increment day of month at A0 by A1, advancing #months when necessary
		accepts: A0=p->time, A1=increment
	800D579C	increment #hours at A0 by A1, advancing day of month when necessary
		accepts: A0=p->time, A1=increment
	800D57FC	increment #minutes at A0 by A1, advancing #hours when necessary
		accepts: A0=p->time, A1=increment
83DDC	800D585C	increment #seconds at A0 by A1, advancing #minutes when necessary
		accepts: A0=p->time, A1=increment
	800D58BC	increment time at A0 by increments listed in A1
		accepts: A0=p->time, A1=table of increments (seconds, minutes, hours, days, months, years)
	800D5930	decrement #years at A0 by A1
		accepts: A0=p->time, A1=decrement
	800D5944	decrement #months at A0 by A1, depleting #years when necessary
		accepts: A0=p->time, A1=decrement
	800D59E8	decrement day of month at A0 by A1, depleting #months when necessary
		accepts: A0=p->time, A1=decrement
	800D5A8C	decrement #hours at A0 by A1, depleting day of month when necessary
		accepts: A0=p->time, A1=decrement
	800D5B34	decrement #minutes at A0 by A1, depleting #hours when necessary
		accepts: A0=p->time, A1=decrement
	800D5BDC	decrement #seconds at A0 by A1, depleting #minutes when necessary
		accepts: A0=p->time, A1=decrement
	800D5C84	decrement time at A0 by decrements listed in A1
		accepts: A0=p->time, A1=table of decrements (seconds, minutes, hours, days, months, years)
84278	800D5CF8	returns day of week from month,day,year
		accepts: A0=year,A1=month,A2=day of month
		calls: 800D54DC
		returns: V0=day of week
842EC	800D5D6C	copies 2 unaligned words from source to target
		accepts: A0=p->target, A1=p->source
		fries: T6,T7
	800D5D94	V0=TRUE if time/date at A0 valid
		accepts: A0=p->time
	800D5E70
	800D5EA8
	800D5EE4	V0=@(8010D418 + A0->offset)
		accepts: A0=entry
	800D5EFC	V0=TRUE if entry @(8010D418 + A0->offset) nonzero
		accepts: A0=entry
	800D5F28	V0=TRUE if A0=0xD
		accepts: A0=???
	800D5F44
	800D5FA0
	800D60E4
	800D6218
	800D6390	V0=A0; 0->A0+0, 0->A0+4
	800D63A4	
	800D6410	
	800D6490	
	800D64E0	
	800D66D0	
	800D6A10	calls 8002DFA0: A0=@8010F3F0+4C, A1=SP+1C, A2=1
		accepts: A0=
	800D6A44	calls 8002DB20: A0=@8010F3F0+4C, A1=[A0], A2=1
		accepts: A0=
	800D6A74	calls 8002DFA0: A0=@8010F3F0+64, A1=0, A2=1
	800D6AA4	calls 8002DB20: A0=@8010F3F0+64, A1=0, A2=1
	800D6AD4	V0=@8010F3F0 +[A0]+0x2CD
		accepts: A0=offset
	800D6AEC
	800D6B0C
	800D6B34
	800D6B8C
	800D6C88
	800D6ED0
	800D7050
	800D7180
	800D7198
	800D731C
	800D7358
	
	800D88A0	A1->A0+18, A2->A0+1C
	800D88B0	calls 800D88A0: A1=20, A2=16
		accepts: A0=p->???
	800D88D4	does nothing; A0->SP+0
	800D88E0
	
8E78C	800E020C	redirect to 800E15E0: copy matrix to next 0x40, set as current
		calls: 800E15E0: A1=801462B4: p->matrix, A0=A1+40
		fries: V0,A0,A1,T6,T7 [F4,F6,F8,F10,F16,F18]
		returns: A0=p->new matrix
8E7C4	800E0244	PREVIOUS MATRIX: moves pointer at 801462B4 -0x40
		fries: V0,T6,T7
	800E0260
	
8E894	800E0314	does a conversion on the current matrix
		A2=[float] bottom row, A3=mode?, F12=top row, F14=middle row
		calls: 800C7A8C
8E99C	800E041C	another matrix conversion thingie
		accepts: A2=[float] multiplier bottom row,A3=mode, F12=multi top row, F14=multi mid row
	800E0500
	
8F700	800E1180	some long and obscure matrix stuff
8F91C	800E139C	redirect to 800E1180
		calls: 800E1180: A0=p->p->matrix,A1=[80188018]
8F944	800E13C4	redirect to 800E139C: subtracts 0x40 from pointer at A0
		accepts: A0=[80145080] keeps track of current DLs
		calls: 800E139C: A0=entry3 in table-0x40,A1=[80145080]
	800E13F0
	
8FB60	800E15E0	copy matrix from A1 to A0
		accepts: A0=p->target, A1=p->source
		fries: F4,F6,F8,F10,F16,F18
	800E1668
	
	800EED90
9D37C	800EEDFC	calls 800EED90: A1=p->[A1 f/caller]
9D3A0	800EEE20	calls 800EED90: A1=p->[A1 f/caller]
9D3C4	800EEE44	calls 800EED90: A1=p->[A1*1000000 f/caller]
9D3F4	800EEE74	calls 800EED90: A1=p->[A1*10000 f/caller]
	800EEEA4
	
	800F8D5C
		accepts: A0=
	800F8E24
	
	800FA92C
	
AC7A0	800FE220	write time from RTC to A1
		accepts: A0=p->???, A1=p->time
AC9A0	800FE420	if present, copies RTC component 1 to A1; V0=errors
		accepts: A0=p->???, A1=component#
ACA00	800FE480	write RTC status to A1, V0=errors; read/write PIFcmd 6 to channel 5
		accepts: A0=???, A1=p->status
ACBF0	800FE670	convert and write time data A1 to RTC
		accepts: A0=p->???, A1=p->date/time data
ACE50	800FE8D0	write data A2 to RTC component A1
		accepts: A0=p->???, A1=component#, A2=p->RTC data
AD03C	800FEABC	set PIF command 8 to PIFbuffer; write A1 to RTC component A0
		accepts: A0=component#, A1=p->data[8]
AD160	800FEBE0	if present, write A1 to RTC component 1
		accepts: A0=p->???, A1=p->component 1 data
AD250	800FECD0	??? - untoggles data[1]&6 in RTC controller if present
		accepts: A0=p->???
AD390	800FEE10	read data from RTC component to A2
		accepts: A0=p->???, A1=component#, A2=p->data
AD51C	800FEF9C	set PIF command 7 to PIFbuffer; read RTC component A0 to A1
		accepts: A0=component#
AD5E0	800FF060	
	
	
AF230	80100CB0	table used to stow rdram addys for codewords and correct their pointers
	all pointer corrections use this table
	each entry is 0x20 long
	0x0	4	codeword start
	0x4	4	codeword end
	0x8	4	pointer conversion start of binary address
	0xC	4	pointer conversion end of binary address
	0x10	4	rdram address when loaded
	0x14	4	??? pointer conversion EOF-0x24
	0x18	4	0	?
	0x1C	4	00000100 when the entry is loaded into RDRAM
B08B0	80102330
	
B2D10	80104790	30310000	01, part of mempak save verity
B2D14	80104794	NAFJ	used for verity tests on mempak
B2D18	80104798	p->'name' given to mempak saves
B2D1C	8010479C	p->
B2D20	801047A0	p->
B2D24	801047A4	p->
B2D28	801047A8	name of debug gyroid	"Johnny B"
	
B2FF0	80104A70	p->[80139C40]	target for player variables, status among them
	
B501C	80106A9C	? - table of six words
B5034	80106AB4	pointer table: 8008F040, 8008F0A0
B503C	80106ABC	pointer table: 8008F24C - 8008F648	FLASHram verity tests?
B504C	80106ACC	pointer table: 8008FAE0 - 8008FF60
B5068	80106AE8
B5074	80106AF4	table of font character width reductions (C-value for actual)
B5174	80106BF4	table of 7F command sizes and type(?)
	0x60 entries (61 max); 2 bytes each entry
	0x0	1	size of command in bytes (min 2)
	0x1	1	unknown
B5234	80106CB4	DL: 
B52A0	80106D30
B5320	80106DA0	DL: 
B5390	80106E20	menu jump preload list, loading data via codewords
B53A0	80106E20	741EA0	[6EF0B0]
B53D0	80106E50	73F4D0	[6ED6C0]	debug menu
B5400	80106E80	741FB0	[6EF1A0]	../m_play.c
B5430	80106EB0	743B70	[6F05A0]
B5460	80106EE0	743CD0	[6F0700]
B5490	80106F10	744020	[6F09C0]	../m_trademark.c
B54C0	80106F40	747AA0	[6F2D60]
B54F0	80106F70	7486E0	[6F3740]	save file manager
B5520	80106FA0	7492E0	[6F3F30]	../famicom_emu.c
B5550	80106FD0	7745B0	[70E0E0]
B5580	80107000	#menus
B5584	80107004	???
B55A0	80107020	pointer table	0x61 entries
	computes expansion size for certain 7F types
B5724	801071A4	max sizes for entries in multibank
	superz.tbl	maila.tbl	mailb.tbl	mailc.tbl
	psz.tbl
B5738	801071B8	offsets to each part of the complicated tbl routine
	superz.tbl	maila.tbl	mailb.tbl	mailc.tbl
	psz.tbl
B574C	801071CC	offsets to each part of the complicated txt routine
	superz.txt	maila.txt	mailb.txt	mailc.txt
	psz.txt
	801071E0

B60F0	80107B70	7F50 colour command: royal blue
B60F8	80107B78	colour samples	0x3 each entry; 5 total
		0	black
		1	royal purple
		2	forest green
		3	royal blue
		4	blood red
B6108	80107B88	prototype for generated 7F50 colour command
B6110	80107B90	?	table tied to text characters
	80107C90
	
B6238	80107CB8	pointers to 7F command handlers
	0x60 entries (61 max)
B63C0	80107E40	point table: UR & LL of character text balloons
B6440	80107EC0	point table: top & bottom of character text balloons
B64C0	80107F40	point table: UL & LR corners of character text balloons
B6540	80107FC0	image: UL & LR corners of character text balloons
	0x800	
B6D40	801087C0	image: top & bottom of character text balloons
	0x1000	
B7D40	801097C0	image: UR & LL of character text balloons
	0x1000	
B8D40	8010A7C0	DL: main body of character text balloons
B8E68	8010A8E8	point table: character name balloon
B8EA8	8010A928	image: character name balloon
	0x400
B92A8	8010AD28	DL: character name balloon
B9318	8010AD98	DL: attributes for character balloons
B9380	8010AE00	rdram pointers
		8009FE6C	
		8009FFB0	
		800A04E4	
		800A2538	
		800A268C	
		800A27FC	
		800A289C	
		800A2948	
		8009FE4C	
		8009FF68	
		800A0478	
		800A24D0	
		800A2648	
		800A2784	
		800A287C	
		800A2904	
B93C0	8010AE40	19 07 F8 11 05 C3	Farway Museum

B9A90	8010B510	table of some kind	0xC each
	0x0	2	text ID?
	0x2	2	RESERVED
	0x4	4	
	0x8	4	

B9D90	8010B810	D4 8E A6 90 85 42	"Johnny B"	default character name
B9D98	8010B818	D3 AF 9D 20		default catchphrase

BB0B0	8010CB30	display list snippet
BB0E0	8010CB60	display list snippet
BB110	8010CB90	display list snippet
BB140	8010CBC0	display list snippet
BB170	8010CBF0	display list snippet
BB1A0	8010CC20	display list snippet
BB1D0	8010CC50	display list snippet
BB200	8010CC80	display list snippet
BB230	8010CCB0	display list snippet
BB260	8010CCE0	display list snippet
BB290	8010CD10	display list snippet
BB2C0	8010CD40	display list snippet
BB2F0	8010CD70	display list snippet
BB320	8010CDA0	display list snippet
BB350	8010CDD0	display list snippet
BB380	8010CE00	display list snippet
BB3E0	8010CE60	display list snippet
BB410	8010CE90	display list snippet
BB438	8010CEB8

BC368	8010DDE8	codeword tables	0x8 each; start codeword + end codeword
	BC600	8010E080	codeword tables: character geometry
BCFD8	8010EA58	codeword table	0x1C each
	0x0	4	
	0x4	4	
	0x8	4	
	0xC	4	codeword start
	0x10	4	codeword end

BD4E0	8010EF60	toggle - tied to FLASHram verity tests
BD4E4	8010EF64
	
BD4F0	8010EF70	mempak 'name' for save files
		DOUBUTSUNOMORI
		1D 28 2E 1B 2E 2D 2C 2E 27 28 26 28 2B 22 
		ANIMAL FOREST
		1A 27 22 26 1A 25 0F 1F 28 2B 1E 2C 2D 00

	80113898	tone of voice
		0	normal
		1	angry
		2	disappointed
		3	happy
		4	tired
	801138A0	? tone counter
	801138A4	? tone counter
		
C2C80	80114700	sound sequence pointers	0x91 entries
C35A0	80115020	sound sequence pointers	6 entries
C3610	80115090	sound sequence pointers	0xCE entries	animalese samples, most likely
C4300	80115D80

C46E0	80116160	c-style display strings
	%4d %1d%1d %1d%1d %1d%1d %1d%1d 
C4704	80116184	c-style display strings
	%1d%1d %4d %1d%1d %1d%1d %1d%1d
C4730	801161B0	ACTOR NAME is NULL
C4748	801161C8	ACTOR NAME %08x:%s
C475C	801161DC	Actor_draw
C4770	801161F0

C4780	80116200	actor_dlftbls %u[0xA]
C4794	80116214	No. RamStart- RamEnd cn  Name[0xA]
C47B4	80116234	%3d %08x-%08x %3d %s[0xA]
		
C4828	801162A8	5 pointers to LR clock time retrieval routines
	801162BC

C54B0	80116F30	"../m_font_basic.c"
C54C4	80116F44	"../m_font_basic.c"
C54D8	80116F58	"../m_font_mark.c"
C54EC	80116F6C	"../m_font_mark.c"
C5500	80116F80	[float]
C5504	80116F84	[float]
C5508	80116F88	p->subroutine: numerical 1 to '1'
C550C	80116F8C	p->subroutine: numerical 2 to '2'
C5510	80116F90	p->subroutine: numerical 3 to '3'
C5514	80116F94	p->subroutine: numerical 4 to '4'
C5518	80116F98	p->subroutine: numerical 5 to '5'
C551C	80116F9C	p->subroutine: numerical 6 to '6'
C5520	80116FA0	p->subroutine: numerical 7 to '7'
C5524	80116FA4	p->subroutine: numerical 8 to '8'
C5528	80116FA8	p->subroutine: numerical 9 to '9'
	
C5540	80116FC0	"../m_handbill.c"
C5550	80116FD0	"../m_handbill.c"
C5560	80116FE0	"../m_handbill.c"
C5570	80116FF0	"../m_handbill.c"
C5580	80117000	"../m_handbill.c"
C5590	80117010	"../m_handbill.c"
C55A0	80117020	"../m_handbill.c"
C55B0	80117030	"../m_handbill.c"
C55C0	80117040	"../m_handbill.c"
C55D0	80117050	"../m_handbill.c"
C55E0	80117060	"../m_handbill.c"
C55F0	80117070	"../m_handbill.c"
C5600	80117080	"../m_handbill.c"
C5610	80117090	"../m_handbill.c"
C5610	80117090	[float] 

C5630	801170B0	"../m_item_name.c"

C57D0	80117250	"../m_msg_main.c"	see 8009E388
C57E0	80117260	"../m_msg_main.c"
C57F0	80117270	"../m_msg_main.c"
C5800	80117280	"../m_msg_main.c"

C5830	801172B0	"../m_npc.c"
C583C	801172BC	"../m_npc.c"
C5848	801172C8	"../m_npc.c"
C5854	801172D4	"../m_npc.c"
C5860	801172E0	"../m_npc.c"
C586C	801172EC	"../m_npc.c"
C5878	801172F8	"../m_npc.c"
C5884	80117304	"%4x %3d %3d"
C5890	80117310	"%4x %3d ---"
C589C	8011731C	"%4x --- %3d"
C58A8	80117328	"%4x --- ---"
C58B4	80117334	"%4x "
C58BC	8011733C	"**** "
C58C4	80117344	"%4x %3d "
C58D0	80117350	"**** *** "
C58E0	80117360

C5900	80117380	"../m_player_lib.c"
C5914	80117394	"../m_player_lib.c"
C5928	801173A8	"../m_player_lib.c"
C593C	801173BC	"../m_player_lib.c"
C5950	801173D0	"../m_player_lib.c"
C5964	801173E4	"../m_player_lib.c"
C5978	801173F8	"../m_player_lib.c"
C598C	8011740C	"../m_player_lib.c"
C59A0	80117420

C5C14	80117694	"RandomTry %d"
C5C24	801176A4	"RandomStep %s"
C5C34	801176B4
	
C5CC0	80117740	"../m_scene_ftr.c"
C5CE0	80117760	"../m_shop.c"
C5CEC	8011776C	"../m_shop.c"
C5CF8	80117778	"../m_shop.c"
C5D04	80117784	"../m_shop.c"
C5D10	80117790	"Pre"
C5D14	80117794	"End"
C5D18	80117798	"Opn"
C5D1C	8011779C	"Rnw"
C5D20	801177A0	"%2d %2d %s"
C5D2C	801177AC	"A%2d,%2d,%2d,%2d,%2d"
C5D44	801177C4	"%d %d %s->%d.%d.%d"
C5D58	801177D8	"A%2d,%2d,%2d,%2d,%2d"
C5D70	801177F0	"B%2d,%2d,%2d,%2d,%2d"
C5D88	80117808	"C%2d,%2d,%2d,%2d,%2d"
C5D9C	8011781C	
	
C5E60	801178E0	"../m_string.c"	even indices
C5E70	801178F0	"../m_string.c"	index 0
C5E80	80117900	"../m_string.c"	odd indices
C5E90	80117910	"../m_string.c"	text grab
C5EA0	80117920	"submenu_ovl"
C5EAC	8011792C	"player_actor"
C5EBC	8011793C	"SubmenuArea_visit\r"
C5ED0	80117950	"RamStart-RamEnd Offset\r"
C5EEC	8011796C	"%08x-%80x %06x"
C5EFC	8011797C	" PC:%08x"
C5F08	80117988	" RA:%08x"
C5F14	80117994	"\r"
C5F18	80117998	"\r"
C5F1C	8011799C	"player information\r"
C5F30	801179B0	"main_index         :%d %d\r"
C5F4C	801179CC	"request_main_index :%d %d %d\r"
C5F6C	801179EC	"pos :%d %d %d\r"
C5F7C	801179FC	"angleY :%d %d\r"
	
C5FB0	80117A30	"../m_scene.c"
C5FC0	80117A40	"../m_scene.c"
C5FD0	80117A50	"../m_scene.c"
	
C6000	80117A80	"../m_titledemo.c"

C6060	80117AE0	NULL message board controller sample
C6068	80117AE8	
	
C6110	80117B90	"sFRm_flashrom"

C62A0	80117D60	DEBUG TEXT - replaced with 7Fext command table in hax

C9600	8011B0C0

C9738	8011B1F8	"RSP Gfx ucode F3DZEX.NoN  fifo 2.08J Yoshitaka Yasumoto/Kawasedo 1999.\n"
C9780	8011B240

C9B58	8011B618	"RSP Gfx ucode S2DEX       fifo 2.08  Yoshitaka Yasumoto 1999 Nintendo.\n"
C9BA0	8011B668

C9DB0	8011B830	end of file

+-+-+-+-+

nothing to do with rom - just handy...

80124840	player collision variables
 4	4	(float) (03E00000 flags + 7FFFFFFF)*10.0 + base
 8	4	(float) (001F0000 flags + 7FFFFFFF)*10.0 + base
 C	4	(float) (0000F800 flags + 7FFFFFFF)*10.0 + base
10	4	(float) (000007C0 flags + 7FFFFFFF)*10.0 + base
14	4	(float) base value
28	4	TRUE if 80000000 flag set
2C	1	tile type

80126EA0	save data file
 20	80126EC0	playerdata (see below)
 2F6A	80129E0A	message board messages	0x68 each
 4080	8012AF20	pl1.gyroid message
 40C0	8012AF60	
 40D0	8012AF70	pl1.name
 40D6	8012AF76	pl1.town 
 4BC8	8012BA68	pl2.gyroid message
 4C08	8012BAA8	
 4C18	8012BAB8	pl2.name
 4C1E	8012BABE	pl2.town
 5710	8012C5B0	pl3.gyroid message
 5750	8012C5F0	
 5760	8012C600	pl3.name
 5766	8012C606	pl3.town 
 6258	8012D0F8	pl4.gyroid message
 6298	8012D138	
 62A8	8012D148	pl4.name
 62AE	8012D14E	pl4.town

+

80126EC0	playerdata
 10	80126ED0	1	gender (0-boy; 1-girl)
 11	80126ED1	1	face type (0-7)
	
 A86	80127946	8	current time
 A8E	8012794E	1	status
 
 AC4	80127984	8	songs heard flags, ensuring K.K. doesn't nail you with the same one over and over: 34 bits, 1<<n format, word-sized registers
 ACC	8012798C


+_+

80135CE1	1	TRUE for Resetti event?
80135CE2	1	event, maybe?
	1E	???
	1F	Sow Joan
	21	K.K. Slider
80135CE3	1	TRUE if event?

80135CF0	2	

801362D4	set time: year
801362D6	set time: month
801362D7	set time: day
801362D8	set time: 
801362D9	set time: 

80136EA0	start of runtime variables
  0	80136EA0	
  1	80136EA1	
  2	80136EA2

 38	80136ED8	???	0x38 each; ??? entries

118	80136FB8	debug: compiled #seconds (hours+minutes+seconds)
11C	80136FBC	seconds
11D	80136FBD	minutes
11E	80136FBE	hours
11F	80136FBF	day of month
120	80136FC0	day of week
121	80136FC1	month
122	80136FC2	year

12C	80136FCC	

138	80136FD8	p->playerdata
13C	80136FDC
140	80136FE0	TRUE if map acquired
141	80136FE1

208		debug: selected pane (0-options; 1-settings)
20C	
210		debug: selected setting

56C	8013740C	weather
		0	clear
		1	rain
		2	snow
		3	sakura
		4	random (autumn?)
	8013740E

7E0	80137680	data source
7E4	80137684	(short) 

A38	801378D8	beesting register
		0	okay
		1	stung

A80	80137920
A82	80137922	???

AB0	80137950	???	byte

+_+

80139C40	player variables, probably
D8	80139D18	status
		0	normal
		1	popular
		2	unpopular
		3	unlucky
		4	money charm
		5	rare item charm
		6	???
		7	???
		8	???
		9	???
		FF	neutral

+-+-+-+-+

80141FF0	msg_txt bank	used for displayed text during game
0x0	80141FF0	TRUE when text successfully loaded
0x4	80141FF4	currently loaded msg_txt ID
0x8	80141FF8	size of text
0xC	80141FFC	unknown.  note read, always set to 0
0x10	80142000	0x400 buffer for text

80142410	text controller breakdown:
0xC	8014241C	p->header for message_txt bank
0x20	80142430	
0x38	80142448	1st of 2x string variable spots (0xA each)
0x100	80142510	1st of 1x string variable spots (0xA each)
0x176	80142586	character name text color
0x17A	8014258A	character name balloon color
0x17E	8014258E	color of character text balloon oval
0x182	80142592	font color 1
0x186	80142596	font color 2
0x18A	8014259A	font color 3
0x18E	8014259E	font color 4
0x192	801425A2	color of advance arrow

0x1AC	801425BC	font color# in use

801425C0	selectmenu subsection of text controller
0x1B0	801425C0	selectmenu+0: 

0x20C	8014261C	selectmenu+5C: option 1 strlen
0x210	80142620	selectmenu+60: option 2 strlen
0x214	80142624	selectmenu+64: option 3 strlen
0x218	80142628	selectmenu+68: option 4 strlen

0x230	80142640	selectmenu+80: selected option
0x234	80142644	selectmenu+84: highlighted option

0x268	80142678	selectmenu+B8: allow B button to default escape menu

0x280	80142690	slot 1 print colour
0x281	80142691	slot 2 print colour
0x282	80142692	slot 3 print colour
0x283	80142693	

0x28C	8014269C	switches:
	00000001	whisper if set
	00000002	unknown; set by 7F5B
	00000004	
	00000008	pause switch
	00000010	
	00000020	[use: 800A306C]
	00000040	
	00000080	[test: 8009EA18]
	00000100	in wait loop?
0x294	801426A4	[float] wait period
0x2A0	801426B0	current position
0x2BC	801426CC	TRUE when quick-advance used on a page
0x2C0	801426D0	TRUE allows quick-advance (press A or B to advance text)
0x2C4	801426D4	next text ID to load, when this one's done with
0x2C8	801426D8	
0x2CC	801426DC	1 loads text from controller+0x2C4
0x2D0	801426E0	
0x2D4	801426E4	
0x2D4	801426E8	
0x2D4	801426EC	
0x2E0	801426F0	
0x2E4	801426F4	msg.txt entry to load (used for character responses)

@_@

80145B30	controller 1 input table
80145B48	controller 2 input table
	0x0	2	current buttons
	0x2	1	current horzontal stick position
	0x3	1	current vertical stick position

80147760	print controller
	+0	80147760	p->current text
	+10	80147710	(float) cur. x offset	size*0.03
	+14	80147714	(float) cur. y offset	size*0.03
	+18	80147718	(float) cur. x scale	0.0 - 1.0
	+1C	8014771C	(float) cur. y scale	0.0 - 1.0
	+20	80147720	(float) x offset	size*0.03
	+24	80147724	(float) y offset	size*0.03
	+28	80147728	(float) x scale	0.0 - 1.0
	+2C	8014772C	(float) y scale	0.0 - 1.0
	+30	80147790	(float) volume
	+34	80147794	7F50 print colour
	+38	80147798	#bytes to colourize
	+39	80147799
	+3C	8014779C	+5	control byte for text display mode (hax: 1=fixed width,0 var)
	+40	801477A0	p->text controller
	+54	801477B4	(float) volume+fontsize

+_+

80229050	some kind of manager	(pointer at 8010EF90)
0x0	80229050	4	p->???
0x4	80229054	4	p->???
0x8	80229058	4	p->???
0xC	8022905C	4	pointer correction codeword when loading binary
	acts as entry point and used to pull binaries from ROM
0x10	80229060	4	size(?) of binary when loading
0x14	80229064	C	current controller 1 input
0x20	80229070	C	held controller 1 input(?)
0x2C	8022907C	C	current controller 2 input
0x38	80229088	C	held controller 2 input(?)
0x44	
0x9E	802290EE	1	TRUE to load binary; automatically set to 0 when binary loaded
0x9F	802290EF	1	TRUE when binary loaded; set to 0 before loading a binary

0x1D9C	8022ADEC	2	music ID# of requested song or 2A37 if not found

+_+

	Mail controller
0x0	1	
0x1	1	
0x2	1	
0x3	1	
0x4	1	
0x5	1	superscript length
0x6	1	message length
0x7	1	postscript length

0x2E	1	
0x2F	1	superscript name offset
0x30	1	
0x31	1	stationary (0-3F)
0x32	0xA	superscript text
0x3C	0x60	message text
0x9C	0x10	postscript text
0xAC	
0xBC	4	display list offset

+_+

803BD200	Type controller (floating memory position)
0x0	1	currently highlighted character
0x1	1	previosuly highlighted character
0x2	1	
0x3	1	spin target
0x4	1	current character set
0x5	1	current character page offset
0x6	2	current sub-character set or -1
0x8	4	
0xC	2	cursor blink state
0xE	1	
0xF	1	
0x10	1
0x11	1	mode (0-8)
	0	no action
	1	cursor right
	2	cursor left
	3	cursor up
	4	cursor down
	5	save
	6	backspace
	7	convert char
	8	insert char
0x12	1
0x13	1	char to append to text
0x14	1	wheel type (0-normal, 2-subset)
0x15	1	TRUE when amended	
0x16	2	position to cursor from start of text
0x18	2	max columns (chars per row)
0x1A	2	max rows
0x1C	2	message length
0x1E	2	conversion character to appear on R button (-1 for "Special")
0x20	2	cursor pos.column
0x22	2	cursor pos.row
0x24	4	p->text
