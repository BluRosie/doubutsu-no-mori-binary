/*
 * This file contains autogenerated routines for dispatching and disassembling
 * MIPS opcodes.
 *
 * The code has been generated by mipsgen.
 *
 * See scripts/mipsgen.rb for the code generator framework.
 * See codegen/cgen.rb for C specific information.
 */

static char* format_register(uint32_t re)
{
    char* reg;

    switch (re)
    {
        case 0:
            reg = "$zero";
            break;
        case 1:
            reg = "at";
            break;
        case 2:
            reg = "v0";
            break;
        case 3:
            reg = "v1";
            break;
        case 4:
            reg = "a0";
            break;
        case 5:
            reg = "a1";
            break;
        case 6:
            reg = "a2";
            break;
        case 7:
            reg = "a3";
            break;
        case 8:
            reg = "t0";
            break;
        case 9:
            reg = "t1";
            break;
        case 10:
            reg = "t2";
            break;
        case 11:
            reg = "t3";
            break;
        case 12:
            reg = "t4";
            break;
        case 13:
            reg = "t5";
            break;
        case 14:
            reg = "t6";
            break;
        case 15:
            reg = "t7";
            break;
        case 16:
            reg = "s0";
            break;
        case 17:
            reg = "s1";
            break;
        case 18:
            reg = "s2";
            break;
        case 19:
            reg = "s3";
            break;
        case 20:
            reg = "s4";
            break;
        case 21:
            reg = "s5";
            break;
        case 22:
            reg = "s6";
            break;
        case 23:
            reg = "s7";
            break;
        case 24:
            reg = "t8";
            break;
        case 25:
            reg = "t9";
            break;
        case 26:
            reg = "k0";
            break;
        case 27:
            reg = "k1";
            break;
        case 28:
            reg = "gp";
            break;
        case 29:
            reg = "sp";
            break;
        case 30:
            reg = "fp";
            break;
        case 31:
            reg = "ra";
            break;
    }

    return reg;
}

static void decode_j(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (_delay)
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = true;
    if (gettarget(pc,op) >= programbase && gettarget(pc,op) < programbase + filesize)
        snprintf(outbuf,n,"j _%08x",gettarget(pc,op));
    else
        snprintf(outbuf,n,"j 0x%08x",gettarget(pc,op));
}

static void decode_jal(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (_delay)
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = true;
    if (gettarget(pc,op) >= programbase && gettarget(pc,op) < programbase + filesize)
        snprintf(outbuf,n,"jal _%08x",gettarget(pc,op));
    else
        snprintf(outbuf,n,"jal 0x%08x",gettarget(pc,op));
}

static void decode_beq(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (_delay)
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = true;
    if (getbroff(pc,op) >= programbase && getbroff(pc,op) < programbase + filesize)
        snprintf(outbuf,n,"beq %s, %s, _%08x",format_register(getrs(op)),format_register(getrt(op)),getbroff(pc,op));
    else
        snprintf(outbuf,n,"beq %s, %s, 0x%08x",format_register(getrs(op)),format_register(getrt(op)),getbroff(pc,op));
}

static void decode_bne(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (_delay)
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = true;
    if (getbroff(pc,op) >= programbase && getbroff(pc,op) < programbase + filesize)
        snprintf(outbuf,n,"bne %s, %s, _%08x",format_register(getrs(op)),format_register(getrt(op)),getbroff(pc,op));
    else
        snprintf(outbuf,n,"bne %s, %s, 0x%08x",format_register(getrs(op)),format_register(getrt(op)),getbroff(pc,op));
}

static void decode_blez(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc1f0000, 0x18000000)) || _delay)
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = true;
    if (getbroff(pc,op) >= programbase && getbroff(pc,op) < programbase + filesize)
        snprintf(outbuf,n,"blez %s, _%08x",format_register(getrs(op)),getbroff(pc,op));
    else
        snprintf(outbuf,n,"blez %s, 0x%08x",format_register(getrs(op)),getbroff(pc,op));
}

static void decode_bgtz(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc1f0000, 0x1c000000)) || _delay)
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = true;
    if (getbroff(pc,op) >= programbase && getbroff(pc,op) < programbase + filesize)
        snprintf(outbuf,n,"bgtz %s, _%08x",format_register(getrs(op)),getbroff(pc,op));
    else
        snprintf(outbuf,n,"bgtz %s, 0x%08x",format_register(getrs(op)),getbroff(pc,op));
}

static void decode_addi(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"addi %s, %s, 0x%x",format_register(getrt(op)),format_register(getrs(op)),getsimm(op));
}

static void decode_addiu(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"addiu %s, %s, 0x%x",format_register(getrt(op)),format_register(getrs(op)),getsimm(op));
}

static void decode_slti(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"slti %s, %s, 0x%x",format_register(getrt(op)),format_register(getrs(op)),getsimm(op));
}

static void decode_sltiu(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"sltiu %s, %s, 0x%x",format_register(getrt(op)),format_register(getrs(op)),getsimm(op));
}

static void decode_andi(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"andi %s, %s, 0x%x",format_register(getrt(op)),format_register(getrs(op)),getimm(op));
}

static void decode_ori(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"ori %s, %s, 0x%x",format_register(getrt(op)),format_register(getrs(op)),getimm(op));
}

static void decode_xori(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"xori %s, %s, 0x%x",format_register(getrt(op)),format_register(getrs(op)),getimm(op));
}

static void decode_lui(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffe00000, 0x3c000000)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"lui %s, 0x%x",format_register(getrt(op)),getimm(op));
}

static void decode_beql(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (_delay)
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = true;
    if (getbroff(pc,op) >= programbase && getbroff(pc,op) < programbase + filesize)
        snprintf(outbuf,n,"beql %s, %s, _%08x",format_register(getrs(op)),format_register(getrt(op)),getbroff(pc,op));
    else
        snprintf(outbuf,n,"beql %s, %s, 0x%08x",format_register(getrs(op)),format_register(getrt(op)),getbroff(pc,op));
}

static void decode_bnel(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (_delay)
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = true;
    if (getbroff(pc,op) >= programbase && getbroff(pc,op) < programbase + filesize)
        snprintf(outbuf,n,"bnel %s, %s, _%08x",format_register(getrs(op)),format_register(getrt(op)),getbroff(pc,op));
    else
        snprintf(outbuf,n,"bnel %s, %s, 0x%08x",format_register(getrs(op)),format_register(getrt(op)),getbroff(pc,op));
}

static void decode_blezl(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc1f0000, 0x58000000)) || _delay)
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = true;
    if (getbroff(pc,op) >= programbase && getbroff(pc,op) < programbase + filesize)
        snprintf(outbuf,n,"blezl %s, _%08x",format_register(getrs(op)),getbroff(pc,op));
    else
        snprintf(outbuf,n,"blezl %s, 0x%08x",format_register(getrs(op)),getbroff(pc,op));
}

static void decode_bgtzl(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc1f0000, 0x5c000000)) || _delay)
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = true;
    if (getbroff(pc,op) >= programbase && getbroff(pc,op) < programbase + filesize)
        snprintf(outbuf,n,"bgtzl %s, _%08x",format_register(getrs(op)),getbroff(pc,op));
    else
        snprintf(outbuf,n,"bgtzl %s, 0x%08x",format_register(getrs(op)),getbroff(pc,op));
}

static void decode_lb(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"lb %s, 0x%x(%s)",format_register(getrt(op)),getoffset(op),format_register(getbase(op)));
}

static void decode_lh(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"lh %s, 0x%x(%s)",format_register(getrt(op)),getoffset(op),format_register(getbase(op)));
}

static void decode_lwl(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"lwl %s, 0x%x(%s)",format_register(getrt(op)),getoffset(op),format_register(getbase(op)));
}

static void decode_lw(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"lw %s, 0x%x(%s)",format_register(getrt(op)),getoffset(op),format_register(getbase(op)));
}

static void decode_lbu(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"lbu %s, 0x%x(%s)",format_register(getrt(op)),getoffset(op),format_register(getbase(op)));
}

static void decode_lhu(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"lhu %s, 0x%x(%s)",format_register(getrt(op)),getoffset(op),format_register(getbase(op)));
}

static void decode_lwr(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"lwr %s, 0x%x(%s)",format_register(getrt(op)),getoffset(op),format_register(getbase(op)));
}

static void decode_sb(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"sb %s, 0x%x(%s)",format_register(getrt(op)),getoffset(op),format_register(getbase(op)));
}

static void decode_sh(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"sh %s, 0x%x(%s)",format_register(getrt(op)),getoffset(op),format_register(getbase(op)));
}

static void decode_swl(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"swl %s, 0x%x(%s)",format_register(getrt(op)),getoffset(op),format_register(getbase(op)));
}

static void decode_sw(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"sw %s, 0x%x(%s)",format_register(getrt(op)),getoffset(op),format_register(getbase(op)));
}

static void decode_swr(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"swr %s, 0x%x(%s)",format_register(getrt(op)),getoffset(op),format_register(getbase(op)));
}

static void decode_cache(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"cache 0x%x, 0x%x(%s)",getcacheop(op),getoffset(op),format_register(getbase(op)));
}

static void decode_ll(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"ll %s, 0x%x(%s)",format_register(getrt(op)),getoffset(op),format_register(getbase(op)));
}

static void decode_pref(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    decode_illegal(outbuf, n, pc, op);

    // snprintf(outbuf,n,"pref 0x%x, 0x%x(%s)",getprefhint(op),getoffset(op),format_register(getbase(op)));
}

static void decode_sc(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"sc %s, 0x%x(%s)",format_register(getrt(op)),getoffset(op),format_register(getbase(op)));
}

static void decode_sll(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffe0003f, 0x00000000)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;

    if (!op)
        snprintf(outbuf,n,"nop");
    else
        snprintf(outbuf,n,"sll %s, %s, 0x%x",format_register(getrd(op)),format_register(getrt(op)),getsa(op));
}

static void decode_srl(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffe0003f, 0x00000002)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"srl %s, %s, 0x%x",format_register(getrd(op)),format_register(getrt(op)),getsa(op));
}

static void decode_sra(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffe0003f, 0x00000003)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"sra %s, %s, 0x%x",format_register(getrd(op)),format_register(getrt(op)),getsa(op));
}

static void decode_sllv(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 0x00000004)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"sllv %s, %s, %s",format_register(getrd(op)),format_register(getrt(op)),format_register(getrs(op)));
}

static void decode_srlv(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 0x00000006)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"srlv %s, %s, %s",format_register(getrd(op)),format_register(getrt(op)),format_register(getrs(op)));
}

static void decode_srav(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 0x00000007)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"srav %s, %s, %s",format_register(getrd(op)),format_register(getrt(op)),format_register(getrs(op)));
}

static void decode_jr(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc1fffff, 0x00000008)) || _delay)
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = true;
    snprintf(outbuf,n,"jr %s",format_register(getrs(op)));
}

static void decode_jalr(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc1f07ff, 0x00000009) && check_jalr(getrs(op), getrd(op)))
     || _delay)
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = true;
    snprintf(outbuf,n,"jalr %s, %s", format_register(getrs(op)), format_register(getrd(op)));
}

static void decode_movz(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    //if (!(check_opcode(op, 0xfc0007ff, 0x0000000a)))
    //{
        decode_illegal(outbuf, n, pc, op);
    //    return;
    //}

    //snprintf(outbuf,n,"movz %s, %s, %s",format_register(getrd(op)),format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_movn(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    //if (!(check_opcode(op, 0xfc0007ff, 0x0000000b)))
    //{
        decode_illegal(outbuf, n, pc, op);
    //    return;
    //}

    //snprintf(outbuf,n,"movn %s, %s, %s",format_register(getrd(op)),format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_syscall(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (_delay)
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    snprintf(outbuf,n,"syscall 0x%x",getsyscode(op));
}

static void decode_break(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (_delay)
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    snprintf(outbuf,n,"break 0x%x",getsyscode(op));
}

static void decode_sync(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfffff83f, 0x0000000f))
     || (op & 0xfffffff0)) // if anything but the last 4 bits is filled, the sync cmd is illegal to preserve data
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"sync");
}

static void decode_mfhi(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffff07ff, 0x00000010)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"mfhi %s",format_register(getrd(op)));
}

static void decode_mthi(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc1fffff, 0x00000011)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"mthi %s",format_register(getrs(op)));
}

static void decode_mflo(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffff07ff, 0x00000012)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"mflo %s",format_register(getrd(op)));
}

static void decode_mtlo(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc1fffff, 0x00000013)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"mtlo %s",format_register(getrs(op)));
}

static void decode_mult(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc00ffff, 0x00000018)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"mult %s, %s",format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_multu(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc00ffff, 0x00000019)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"multu %s, %s",format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_div(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc00ffff, 0x0000001a)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"div %s, %s",format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_divu(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc00ffff, 0x0000001b)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"divu %s, %s",format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_add(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 0x00000020)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"add %s, %s, %s",format_register(getrd(op)),format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_addu(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 0x00000021)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"addu %s, %s, %s",format_register(getrd(op)),format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_sub(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 0x00000022)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"sub %s, %s, %s",format_register(getrd(op)),format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_subu(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 0x00000023)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"subu %s, %s, %s",format_register(getrd(op)),format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_and(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 0x00000024)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"and %s, %s, %s",format_register(getrd(op)),format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_or(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 0x00000025)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"or %s, %s, %s",format_register(getrd(op)),format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_xor(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 0x00000026)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"xor %s, %s, %s",format_register(getrd(op)),format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_nor(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 0x00000027)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"nor %s, %s, %s",format_register(getrd(op)),format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_slt(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 0x0000002a)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"slt %s, %s, %s",format_register(getrd(op)),format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_sltu(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 0x0000002b)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"sltu %s, %s, %s",format_register(getrd(op)),format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_tge(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"tge %s, %s, 0x%x",format_register(getrs(op)),format_register(getrt(op)),gettrapcode(op));
}

static void decode_tgeu(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"tgeu %s, %s, 0x%x",format_register(getrs(op)),format_register(getrt(op)),gettrapcode(op));
}

static void decode_tlt(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"tlt %s, %s, 0x%x",format_register(getrs(op)),format_register(getrt(op)),gettrapcode(op));
}

static void decode_tltu(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"tltu %s, %s, 0x%x",format_register(getrs(op)),format_register(getrt(op)),gettrapcode(op));
}

static void decode_teq(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"teq %s, %s, 0x%x",format_register(getrs(op)),format_register(getrt(op)),gettrapcode(op));
}

static void decode_tne(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"tne %s, %s, 0x%x",format_register(getrs(op)),format_register(getrt(op)),gettrapcode(op));
}

static void decode_madd(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    //if (!(check_opcode(op, 0xfc00ffff, 0x70000000)))
    //{
        decode_illegal(outbuf, n, pc, op);
    //    return;
    //}

    //snprintf(outbuf,n,"madd %s, %s",format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_maddu(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    //if (!(check_opcode(op, 0xfc00ffff, 0x70000001)))
    //{
        decode_illegal(outbuf, n, pc, op);
    //    return;
    //}

    //snprintf(outbuf,n,"maddu %s, %s",format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_mul(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 0x70000002)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"mul %s, %s, %s",format_register(getrd(op)),format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_msub(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    //if (!(check_opcode(op, 0xfc00ffff, 0x70000004)))
    //{
        decode_illegal(outbuf, n, pc, op);
    //    return;
    //}

    //snprintf(outbuf,n,"msub %s, %s",format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_msubu(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    //if (!(check_opcode(op, 0xfc00ffff, 0x70000005)))
    //{
        decode_illegal(outbuf, n, pc, op);
    //    return;
    //}

    //snprintf(outbuf,n,"msubu %s, %s",format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_clz(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 0x70000020)&&check_cl(getrt(op), getrd(op))))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"clz %s, %s",format_register(getrd(op)),format_register(getrs(op)));
}

static void decode_clo(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 0x70000021)&&check_cl(getrt(op), getrd(op))))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"clo %s, %s",format_register(getrd(op)),format_register(getrs(op)));
}

static void decode_sdbbp(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    decode_illegal(outbuf, n, pc, op);
    //snprintf(outbuf,n,"sdbbp 0x%x",getsyscode(op));
}

static void decode_bltz(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (_delay)
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = true;
    if (getbroff(pc,op) >= programbase && getbroff(pc,op) < programbase + filesize)
        snprintf(outbuf,n,"bltz %s, _%08x",format_register(getrs(op)),getbroff(pc,op));
    else
        snprintf(outbuf,n,"bltz %s, 0x%08x",format_register(getrs(op)),getbroff(pc,op));
}

static void decode_bgez(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (_delay)
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = true;
    if (getbroff(pc,op) >= programbase && getbroff(pc,op) < programbase + filesize)
        snprintf(outbuf,n,"bgez %s, _%08x",format_register(getrs(op)),getbroff(pc,op));
    else
        snprintf(outbuf,n,"bgez %s, 0x%08x",format_register(getrs(op)),getbroff(pc,op));
}

static void decode_bltzl(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (_delay)
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = true;
    if (getbroff(pc,op) >= programbase && getbroff(pc,op) < programbase + filesize)
        snprintf(outbuf,n,"bltzl %s, _%08x",format_register(getrs(op)),getbroff(pc,op));
    else
        snprintf(outbuf,n,"bltzl %s, 0x%08x",format_register(getrs(op)),getbroff(pc,op));
}

static void decode_bgezl(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (_delay)
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = true;
    if (getbroff(pc,op) >= programbase && getbroff(pc,op) < programbase + filesize)
        snprintf(outbuf,n,"bgezl %s, _%08x",format_register(getrs(op)),getbroff(pc,op));
    else
        snprintf(outbuf,n,"bgezl %s, 0x%08x",format_register(getrs(op)),getbroff(pc,op));
}

static void decode_tgei(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"tgei %s, %d",format_register(getrs(op)),getsimm(op));
}

static void decode_tgeiu(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"tgeiu %s, %d",format_register(getrs(op)),getsimm(op));
}

static void decode_tlti(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"tlti %s, %d",format_register(getrs(op)),getsimm(op));
}

static void decode_tltiu(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"tltiu %s, %d",format_register(getrs(op)),getsimm(op));
}

static void decode_teqi(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"teqi %s, %d",format_register(getrs(op)),getsimm(op));
}

static void decode_tnei(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"tnei %s, %d",format_register(getrs(op)),getsimm(op));
}

static void decode_bltzal(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (_delay)
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = true;
    if (getbroff(pc,op) >= programbase && getbroff(pc,op) < programbase + filesize)
        snprintf(outbuf,n,"bltzal %s, _%08x",format_register(getrs(op)),getbroff(pc,op));
    else
        snprintf(outbuf,n,"bltzal %s, 0x%08x",format_register(getrs(op)),getbroff(pc,op));
}

static void decode_bgezal(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (_delay)
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = true;
    if (getbroff(pc,op) >= programbase && getbroff(pc,op) < programbase + filesize)
        snprintf(outbuf,n,"bgezal %s, _%08x",format_register(getrs(op)),getbroff(pc,op));
    else
        snprintf(outbuf,n,"bgezal %s, 0x%08x",format_register(getrs(op)),getbroff(pc,op));
}

static void decode_bltzall(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (_delay)
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = true;
    if (getbroff(pc,op) >= programbase && getbroff(pc,op) < programbase + filesize)
        snprintf(outbuf,n,"bltzall %s, _%08x",format_register(getrs(op)),getbroff(pc,op));
    else
        snprintf(outbuf,n,"bltzall %s, 0x%08x",format_register(getrs(op)),getbroff(pc,op));
}

static void decode_bgezall(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (_delay)
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = true;
    if (getbroff(pc,op) >= programbase && getbroff(pc,op) < programbase + filesize)
        snprintf(outbuf,n,"bgezall %s, _%08x",format_register(getrs(op)),getbroff(pc,op));
    else
        snprintf(outbuf,n,"bgezall %s, 0x%08x",format_register(getrs(op)),getbroff(pc,op));
}

static void decode_mfc0(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffe007ff, 0x40000000)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"mfc0 %s, $%d",format_register(getrt(op)),getrd(op));
}

static void decode_mtc0(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffe007ff, 0x40800000)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"mtc0 %s, $%d",format_register(getrt(op)),getrd(op));
}

static void decode_tlbr(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffffffff, 0x42000001)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"tlbr");
}

static void decode_tlbwi(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffffffff, 0x42000002)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"tlbwi");
}

static void decode_tlbwr(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffffffff, 0x42000006)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"tlbwr");
}

static void decode_tlbp(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffffffff, 0x42000008)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"tlbp");
}

static void decode_eret(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffffffff, 0x42000018)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"eret");
}

static void decode_deret(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffffffff, 0x4200001f)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"deret");
}

static void decode_wait(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    decode_illegal(outbuf, n, pc, op);
    //snprintf(outbuf,n,"wait 0x%x",getwaitcode(op));
}


// all this shit is new because loadzero left a shit ton unfinished

// daddi/dsubi
static void decode_daddi(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"daddi %s, %s, 0x%x",format_register(getrt(op)),format_register(getrs(op)),getsimm(op));
}

// daddiu/dsubiu
static void decode_daddiu(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"daddiu %s, %s, 0x%x",format_register(getrt(op)),format_register(getrs(op)),getsimm(op));
}

// ldl
static void decode_ldl(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"ldl %s, 0x%x(%s)",format_register(getrt(op)),getoffset(op),format_register(getbase(op)));
}

// ldr
static void decode_ldr(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"ldr %s, 0x%x(%s)",format_register(getrt(op)),getoffset(op),format_register(getbase(op)));
}

// lwu
static void decode_lwu(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"lwu %s, 0x%x(%s)",format_register(getrt(op)),getoffset(op),format_register(getbase(op)));
}

// sdl
static void decode_sdl(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"sdl %s, 0x%x(%s)",format_register(getrt(op)),getoffset(op),format_register(getbase(op)));
}

// sdr
static void decode_sdr(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"sdr %s, 0x%x(%s)",format_register(getrt(op)),getoffset(op),format_register(getbase(op)));
}

// lwc1
static void decode_lwc1(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"lwc1 f%d, 0x%x(%s)",getrt(op),getoffset(op),format_register(getbase(op)));
}

// lld
static void decode_lld(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"lld %s, 0x%x(%s)",format_register(getrt(op)),getoffset(op),format_register(getbase(op)));
}

// ldc1
static void decode_ldc1(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"ldc1 f%d, 0x%x(%s)",getrt(op),getoffset(op),format_register(getbase(op)));
}

// ld
static void decode_ld(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"ld %s, 0x%x(%s)",format_register(getrt(op)),getoffset(op),format_register(getbase(op)));
}

// swc1
static void decode_swc1(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"swc1 f%d, 0x%x(%s)",getrt(op),getoffset(op),format_register(getbase(op)));
}

// scd
static void decode_scd(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"scd %s, 0x%x(%s)",format_register(getrt(op)),getoffset(op),format_register(getbase(op)));
}

// sdc1
static void decode_sdc1(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"sdc1 f%d, 0x%x(%s)",getrt(op),getoffset(op),format_register(getbase(op)));
}

// sd
static void decode_sd(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"sd %s, 0x%x(%s)",format_register(getrt(op)),getoffset(op),format_register(getbase(op)));
}

// dsrlv
static void decode_dsrlv(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 22)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"dsrlv %s, %s, %s",format_register(getrd(op)),format_register(getrt(op)),format_register(getrs(op)));
}

// dsrav
static void decode_dsrav(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 23)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"dsrav %s, %s, %s",format_register(getrd(op)),format_register(getrt(op)),format_register(getrs(op)));
}

// dmult
static void decode_dmult(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 28)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"dmult %s, %s",format_register(getrs(op)),format_register(getrt(op)));
}

// dmultu
static void decode_dmultu(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 29)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"dmultu %s, %s",format_register(getrs(op)),format_register(getrt(op)));
}

// ddiv
static void decode_ddiv(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 30)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"ddiv %s, %s",format_register(getrs(op)),format_register(getrt(op)));
}

// ddivu
static void decode_ddivu(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 31)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"ddivu %s, %s",format_register(getrs(op)),format_register(getrt(op)));
}

// dadd
static void decode_dadd(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 44)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"dadd %s, %s, %s",format_register(getrd(op)),format_register(getrs(op)),format_register(getrt(op)));
}

// daddu
static void decode_daddu(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 45)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"daddu %s, %s, %s",format_register(getrd(op)),format_register(getrs(op)),format_register(getrt(op)));
}

// dsub
static void decode_dsub(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 46)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"dsub %s, %s, %s",format_register(getrd(op)),format_register(getrs(op)),format_register(getrt(op)));
}

// dsubu
static void decode_dsubu(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 47)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"dsubu %s, %s, %s",format_register(getrd(op)),format_register(getrs(op)),format_register(getrt(op)));
}

// dsll
static void decode_dsll(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffe0003f, 0x38)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"dsll %s, %s, 0x%x",format_register(getrd(op)),format_register(getrt(op)),getsa(op));
}

// dsrl
static void decode_dsrl(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffe0003f, 0x3A)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"dsrl %s, %s, 0x%x",format_register(getrd(op)),format_register(getrt(op)),getsa(op));
}

// dsra
static void decode_dsra(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffe0003f, 0x3B)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"dsra %s, %s, 0x%x",format_register(getrd(op)),format_register(getrt(op)),getsa(op));
}

// dsll32
static void decode_dsll32(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffe0003f, 0x3C)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"dsll32 %s, %s, 0x%x",format_register(getrd(op)),format_register(getrt(op)),getsa(op));
}

// dsrl32
static void decode_dsrl32(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffe0003f, 0x3E)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"dsrl32 %s, %s, 0x%x",format_register(getrd(op)),format_register(getrt(op)),getsa(op));
}

// dsra32
static void decode_dsra32(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffe0003f, 0x3F)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"dsra32 %s, %s, 0x%x",format_register(getrd(op)),format_register(getrt(op)),getsa(op));
}

static void decode_dsllv(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 20)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"dsllv %s, %s, %s",format_register(getrd(op)),format_register(getrt(op)),format_register(getrs(op)));
}


// dmfc0
static void decode_dmfc0(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffe007ff, 0x40200000)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"dmfc0 %s, $%d",format_register(getrt(op)),getrd(op));
}

// dmtc0
static void decode_dmtc0(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffe007ff, 0x40A00000)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"dmtc0 %s, $%d",format_register(getrt(op)),getrd(op));
}

// mfc1
static void decode_mfc1(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffe007ff, 0x44000000)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"mfc1 %s, f%d",format_register(getrt(op)),getrd(op));
}

// dmfc1
static void decode_dmfc1(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffe007ff, 0x44200000)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"dmfc1 %s, f%d",format_register(getrt(op)),getrd(op));
}

// cfc1
static void decode_cfc1(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffe007ff, 0x44400000)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"cfc1 %s, $%d",format_register(getrt(op)),getrd(op));
}

// mtc1
static void decode_mtc1(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffe007ff, 0x44800000)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"mtc1 %s, f%d",format_register(getrt(op)),getrd(op));
}

// dmtc1
static void decode_dmtc1(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffe007ff, 0x44A00000)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"dmtc1 %s, f%d",format_register(getrt(op)),getrd(op));
}

// ctc1
static void decode_ctc1(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffe007ff, 0x44C00000)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"ctc1 %s, $%d",format_register(getrt(op)),getrd(op));
}

// bc1f
static void decode_bc1f(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffff0000, 0x45000000)) || _delay)
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = true;
    if (getbroff(pc,op) >= programbase && getbroff(pc,op) < programbase + filesize)
        snprintf(outbuf,n,"bc1f _%x",getbroff(pc,op));
    else
        snprintf(outbuf,n,"bc1f 0x%x",getbroff(pc,op));
}

// bc1t
static void decode_bc1t(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffff0000, 0x45010000)) || _delay)
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = true;
    if (getbroff(pc,op) >= programbase && getbroff(pc,op) < programbase + filesize)
        snprintf(outbuf,n,"bc1t _%x",getbroff(pc,op));
    else
        snprintf(outbuf,n,"bc1t 0x%x",getbroff(pc,op));
}

// bc1fl
static void decode_bc1fl(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffff0000, 0x45020000)) || _delay)
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = true;
    if (getbroff(pc,op) >= programbase && getbroff(pc,op) < programbase + filesize)
        snprintf(outbuf,n,"bc1fl _%x",getbroff(pc,op));
    else
        snprintf(outbuf,n,"bc1fl 0x%x",getbroff(pc,op));
}

// bc1tl
static void decode_bc1tl(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffff0000, 0x45030000)) || _delay)
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = true;
    if (getbroff(pc,op) >= programbase && getbroff(pc,op) < programbase + filesize)
        snprintf(outbuf,n,"bc1tl _%x",getbroff(pc,op));
    else
        snprintf(outbuf,n,"bc1tl 0x%x",getbroff(pc,op));
}

// add.fmt
static void decode_add_fmt(char *outbuf, size_t n, uint32_t pc, uint32_t op, char suffix)
{
    if (!(check_opcode(op, 0xfc00003f, 0x44000000)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"add.%c f%d, f%d, f%d",suffix,getsa(op),getrd(op),getrt(op));
}

// sub.fmt
static void decode_sub_fmt(char *outbuf, size_t n, uint32_t pc, uint32_t op, char suffix)
{
    if (!(check_opcode(op, 0xfc00003f, 0x44000001)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"sub.%c f%d, f%d, f%d",suffix,getsa(op),getrd(op),getrt(op));
}

// mul.fmt
static void decode_mul_fmt(char *outbuf, size_t n, uint32_t pc, uint32_t op, char suffix)
{
    if (!(check_opcode(op, 0xfc00003f, 0x44000002)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"mul.%c f%d, f%d, f%d",suffix,getsa(op),getrd(op),getrt(op));
}

// div.fmt
static void decode_div_fmt(char *outbuf, size_t n, uint32_t pc, uint32_t op, char suffix)
{
    if (!(check_opcode(op, 0xfc00003f, 0x44000003)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"div.%c f%d, f%d, f%d",suffix,getsa(op),getrd(op),getrt(op));
}

// sqrt.fmt
static void decode_sqrt_fmt(char *outbuf, size_t n, uint32_t pc, uint32_t op, char suffix)
{
    if (!(check_opcode(op, 0xfc1f003f, 0x44000004)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"sqrt.%c f%d, f%d",suffix,getsa(op),getrd(op));
}

// abs.fmt
static void decode_abs_fmt(char *outbuf, size_t n, uint32_t pc, uint32_t op, char suffix)
{
    if (!(check_opcode(op, 0xfc1f003f, 0x44000005)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"abs.%c f%d, f%d",suffix,getsa(op),getrd(op));
}

// mov.fmt
static void decode_mov_fmt(char *outbuf, size_t n, uint32_t pc, uint32_t op, char suffix)
{
    if (!(check_opcode(op, 0xfc1f003f, 0x44000006)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"mov.%c f%d, f%d",suffix,getsa(op),getrd(op));
}

// neg.fmt
static void decode_neg_fmt(char *outbuf, size_t n, uint32_t pc, uint32_t op, char suffix)
{
    if (!(check_opcode(op, 0xfc1f003f, 0x44000007)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"neg.%c f%d, f%d",suffix,getsa(op),getrd(op));
}

// round.l.fmt
static void decode_round_l_fmt(char *outbuf, size_t n, uint32_t pc, uint32_t op, char suffix)
{
    if (!(check_opcode(op, 0xfc1f003f, 0x44000008)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"round.l.%c f%d, f%d",suffix,getsa(op),getrd(op));
}

// trunc.l.fmt
static void decode_trunc_l_fmt(char *outbuf, size_t n, uint32_t pc, uint32_t op, char suffix)
{
    if (!(check_opcode(op, 0xfc1f003f, 0x44000009)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"trunc.l.%c f%d, f%d",suffix,getsa(op),getrd(op));
}

// ceil.l.fmt
static void decode_ceil_l_fmt(char *outbuf, size_t n, uint32_t pc, uint32_t op, char suffix)
{
    if (!(check_opcode(op, 0xfc1f003f, 0x4400000a)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"ceil.l.%c f%d, f%d",suffix,getsa(op),getrd(op));
}

// floor.l.fmt
static void decode_floor_l_fmt(char *outbuf, size_t n, uint32_t pc, uint32_t op, char suffix)
{
    if (!(check_opcode(op, 0xfc1f003f, 0x4400000b)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"floor.l.%c f%d, f%d",suffix,getsa(op),getrd(op));
}

// round.w.fmt
static void decode_round_w_fmt(char *outbuf, size_t n, uint32_t pc, uint32_t op, char suffix)
{
    if (!(check_opcode(op, 0xfc1f003f, 0x4400000c)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"round.w.%c f%d, f%d",suffix,getsa(op),getrd(op));
}

// trunc.w.fmt
static void decode_trunc_w_fmt(char *outbuf, size_t n, uint32_t pc, uint32_t op, char suffix)
{
    if (!(check_opcode(op, 0xfc1f003f, 0x4400000d)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"trunc.w.%c f%d, f%d",suffix,getsa(op),getrd(op));
}

// ceil.w.fmt
static void decode_ceil_w_fmt(char *outbuf, size_t n, uint32_t pc, uint32_t op, char suffix)
{
    if (!(check_opcode(op, 0xfc1f003f, 0x4400000e)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"ceil.w.%c f%d, f%d",suffix,getsa(op),getrd(op));
}

// floor.w.fmt
static void decode_floor_w_fmt(char *outbuf, size_t n, uint32_t pc, uint32_t op, char suffix)
{
    if (!(check_opcode(op, 0xfc1f003f, 0x4400000f)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"floor.w.%c f%d, f%d",suffix,getsa(op),getrd(op));
}

// cvt.s.fmt
static void decode_cvt_s_fmt(char *outbuf, size_t n, uint32_t pc, uint32_t op, char suffix)
{
    if (!(check_opcode(op, 0xfc1f003f, 0x44000020)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"cvt.s.%c f%d, f%d",suffix,getsa(op),getrd(op));
}

// cvt.d.fmt
static void decode_cvt_d_fmt(char *outbuf, size_t n, uint32_t pc, uint32_t op, char suffix)
{
    if (!(check_opcode(op, 0xfc1f003f, 0x44000021)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"cvt.d.%c f%d, f%d",suffix,getsa(op),getrd(op));
}

// cvt.w.fmt
static void decode_cvt_w_fmt(char *outbuf, size_t n, uint32_t pc, uint32_t op, char suffix)
{
    if (!(check_opcode(op, 0xfc1f003f, 0x44000024)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"cvt.w.%c f%d, f%d",suffix,getsa(op),getrd(op));
}

// cvt.l.fmt
static void decode_cvt_l_fmt(char *outbuf, size_t n, uint32_t pc, uint32_t op, char suffix)
{
    if (!(check_opcode(op, 0xfc1f003f, 0x44000025)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"cvt.l.%c f%d, f%d",suffix,getsa(op),getrd(op));
}

// c.f.fmt
static void decode_c_f_fmt(char *outbuf, size_t n, uint32_t pc, uint32_t op, char suffix)
{
    if (!(check_opcode(op, 0xfc00073f, 0x44000030)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"c.f.%c f%d, f%d",suffix,getrd(op),getrt(op));
}

// c.un.fmt
static void decode_c_un_fmt(char *outbuf, size_t n, uint32_t pc, uint32_t op, char suffix)
{
    if (!(check_opcode(op, 0xfc00073f, 0x44000031)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"c.un.%c f%d, f%d",suffix,getrd(op),getrt(op));
}

// c.eq.fmt
static void decode_c_eq_fmt(char *outbuf, size_t n, uint32_t pc, uint32_t op, char suffix)
{
    if (!(check_opcode(op, 0xfc00073f, 0x44000032)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"c.eq.%c f%d, f%d",suffix,getrd(op),getrt(op));
}

// c.ueq.fmt
static void decode_c_ueq_fmt(char *outbuf, size_t n, uint32_t pc, uint32_t op, char suffix)
{
    if (!(check_opcode(op, 0xfc00073f, 0x44000033)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"c.ueq.%c f%d, f%d",suffix,getrd(op),getrt(op));
}

// c.olt.fmt
static void decode_c_olt_fmt(char *outbuf, size_t n, uint32_t pc, uint32_t op, char suffix)
{
    if (!(check_opcode(op, 0xfc00073f, 0x44000034)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"c.olt.%c f%d, f%d",suffix,getrd(op),getrt(op));
}

// c.ult.fmt
static void decode_c_ult_fmt(char *outbuf, size_t n, uint32_t pc, uint32_t op, char suffix)
{
    if (!(check_opcode(op, 0xfc00073f, 0x44000035)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"c.ult.%c f%d, f%d",suffix,getrd(op),getrt(op));
}

// c.ole.fmt
static void decode_c_ole_fmt(char *outbuf, size_t n, uint32_t pc, uint32_t op, char suffix)
{
    if (!(check_opcode(op, 0xfc00073f, 0x44000036)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"c.ole.%c f%d, f%d",suffix,getrd(op),getrt(op));
}

// c.ule.fmt
static void decode_c_ule_fmt(char *outbuf, size_t n, uint32_t pc, uint32_t op, char suffix)
{
    if (!(check_opcode(op, 0xfc00073f, 0x44000037)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"c.ule.%c f%d, f%d",suffix,getrd(op),getrt(op));
}

// c.sf.fmt
static void decode_c_sf_fmt(char *outbuf, size_t n, uint32_t pc, uint32_t op, char suffix)
{
    if (!(check_opcode(op, 0xfc00073f, 0x44000038)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"c.sf.%c f%d, f%d",suffix,getrd(op),getrt(op));
}

// n.ngle.fmt
static void decode_n_ngle_fmt(char *outbuf, size_t n, uint32_t pc, uint32_t op, char suffix)
{
    if (!(check_opcode(op, 0xfc00073f, 0x44000039)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"c.ngle.%c f%d, f%d",suffix,getrd(op),getrt(op));
}

// c.seq.fmt
static void decode_c_seq_fmt(char *outbuf, size_t n, uint32_t pc, uint32_t op, char suffix)
{
    if (!(check_opcode(op, 0xfc00073f, 0x4400003a)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"c.seq.%c f%d, f%d",suffix,getrd(op),getrt(op));
}

// c.ngl.fmt
static void decode_c_ngl_fmt(char *outbuf, size_t n, uint32_t pc, uint32_t op, char suffix)
{
    if (!(check_opcode(op, 0xfc00073f, 0x4400003b)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"c.ngl.%c f%d, f%d",suffix,getrd(op),getrt(op));
}

// c.lt.fmt
static void decode_c_lt_fmt(char *outbuf, size_t n, uint32_t pc, uint32_t op, char suffix)
{
    if (!(check_opcode(op, 0xfc00073f, 0x4400003c)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"c.lt.%c f%d, f%d",suffix,getrd(op),getrt(op));
}

// c.nge.fmt
static void decode_c_nge_fmt(char *outbuf, size_t n, uint32_t pc, uint32_t op, char suffix)
{
    if (!(check_opcode(op, 0xfc00073f, 0x4400003d)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"c.nge.%c f%d, f%d",suffix,getrd(op),getrt(op));
}

// c.le.fmt
static void decode_c_le_fmt(char *outbuf, size_t n, uint32_t pc, uint32_t op, char suffix)
{
    if (!(check_opcode(op, 0xfc00073f, 0x4400003e)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"c.le.%c f%d, f%d",suffix,getrd(op),getrt(op));
}

// c.ngt.fmt
static void decode_c_ngt_fmt(char *outbuf, size_t n, uint32_t pc, uint32_t op, char suffix)
{
    if (!(check_opcode(op, 0xfc00073f, 0x4400003f)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"c.ngt.%c f%d, f%d",suffix,getrd(op),getrt(op));
}

static void decode_OPCODE(char *outbuf, size_t n, uint32_t pc, uint32_t op);
static void decode_SPECIAL(char *outbuf, size_t n, uint32_t pc, uint32_t op);
static void decode_REGIMM(char *outbuf, size_t n, uint32_t pc, uint32_t op);
static void decode_COP0(char *outbuf, size_t n, uint32_t pc, uint32_t op);
static void decode_COP0FUNCT(char *outbuf, size_t n, uint32_t pc, uint32_t op);
static void decode_COP1(char *outbuf, size_t n, uint32_t pc, uint32_t op);
static void decode_COP1BC(char *outbuf, size_t n, uint32_t pc, uint32_t op);
static void decode_COP1FUNCT(char *outbuf, size_t n, uint32_t pc, uint32_t op, char suffix);


static void decode_OPCODE(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    switch (getopcode(op))
    {
        case 0:
            decode_SPECIAL(outbuf, n, pc, op);
            break;
        case 1:
            decode_REGIMM(outbuf, n, pc, op);
            break;
        case 2:
            decode_j(outbuf, n, pc, op);
            break;
        case 3:
            decode_jal(outbuf, n, pc, op);
            break;
        case 4:
            decode_beq(outbuf, n, pc, op);
            break;
        case 5:
            decode_bne(outbuf, n, pc, op);
            break;
        case 6:
            decode_blez(outbuf, n, pc, op);
            break;
        case 7:
            decode_bgtz(outbuf, n, pc, op);
            break;
        case 8:
            decode_addi(outbuf, n, pc, op);
            break;
        case 9:
            decode_addiu(outbuf, n, pc, op);
            break;
        case 10:
            decode_slti(outbuf, n, pc, op);
            break;
        case 11:
            decode_sltiu(outbuf, n, pc, op);
            break;
        case 12:
            decode_andi(outbuf, n, pc, op);
            break;
        case 13:
            decode_ori(outbuf, n, pc, op);
            break;
        case 14:
            decode_xori(outbuf, n, pc, op);
            break;
        case 15:
            decode_lui(outbuf, n, pc, op);
            break;
        case 16:
            decode_COP0(outbuf, n, pc, op);
            break;
        case 17: // cop1 - floating point
            decode_COP1(outbuf, n, pc, op);
            break;
        case 18: // cop2 - rsp/psx only
        case 19: // unused
        case 28: // unused
        case 29: // unused
        case 30: // lq - ps2 only
        case 31: // sq - ps2 only
        case 50: // lv.s - ps2 only
        case 54: // lv.q - ps2 only
        case 58: // sv.s - ps2 only
        case 59: // unused
        case 62: // sv.q - ps2 only
            decode_unusable(outbuf, n, pc, op);
            break;
        case 20:
            decode_beql(outbuf, n, pc, op);
            break;
        case 21:
            decode_bnel(outbuf, n, pc, op);
            break;
        case 22:
            decode_blezl(outbuf, n, pc, op);
            break;
        case 23:
            decode_bgtzl(outbuf, n, pc, op);
            break;



        case 24: // daddi/dsubi
            decode_daddi(outbuf, n, pc, op);
            break;
        case 25: // daddiu/dsubiu
            decode_daddiu(outbuf, n, pc, op);
            break;
        case 26: // ldl
            decode_ldl(outbuf, n, pc, op);
            break;
        case 27: // ldr
            decode_ldr(outbuf, n, pc, op);
            break;

        case 39: // lwu
            decode_lwu(outbuf, n, pc, op);
            break;

        case 44: // sdl
            decode_sdl(outbuf, n, pc, op);
            break;
        case 45: // sdr
            decode_sdr(outbuf, n, pc, op);
            break;

        case 49: // lwc1
            decode_lwc1(outbuf, n, pc, op);
            break;

        case 52: // lld
            decode_lld(outbuf, n, pc, op);
            break;
        case 53: // ldc1
            decode_ldc1(outbuf, n, pc, op);
            break;

        case 55: // ld
            decode_ld(outbuf, n, pc, op);
            break;

        case 57: // swc1
            decode_swc1(outbuf, n, pc, op);
            break;

        case 60: // scd
            decode_scd(outbuf, n, pc, op);
            break;
        case 61: // sdc1
            decode_sdc1(outbuf, n, pc, op);
            break;

        case 63: // sd
            decode_sd(outbuf, n, pc, op);
            break;



        case 32:
            decode_lb(outbuf, n, pc, op);
            break;
        case 33:
            decode_lh(outbuf, n, pc, op);
            break;
        case 34:
            decode_lwl(outbuf, n, pc, op);
            break;
        case 35:
            decode_lw(outbuf, n, pc, op);
            break;
        case 36:
            decode_lbu(outbuf, n, pc, op);
            break;
        case 37:
            decode_lhu(outbuf, n, pc, op);
            break;
        case 38:
            decode_lwr(outbuf, n, pc, op);
            break;
        case 40:
            decode_sb(outbuf, n, pc, op);
            break;
        case 41:
            decode_sh(outbuf, n, pc, op);
            break;
        case 42:
            decode_swl(outbuf, n, pc, op);
            break;
        case 43:
            decode_sw(outbuf, n, pc, op);
            break;
        case 46:
            decode_swr(outbuf, n, pc, op);
            break;
        case 47:
            decode_cache(outbuf, n, pc, op);
            break;
        case 48:
            decode_ll(outbuf, n, pc, op);
            break;
        case 51:
            decode_pref(outbuf, n, pc, op);
            break;
        case 56:
            decode_sc(outbuf, n, pc, op);
            break;
        default:
            /* unreachable */
            abort();
    }
}

static void decode_SPECIAL(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    switch (getfunction(op))
    {
        case 0:
            decode_sll(outbuf, n, pc, op);
            break;
        case 1: // unused
        case 5: // unused
        case 14: // unused
        case 21: // unused
        case 40: // mfsa
        case 41: // mtsa
        case 53: // unused
        case 55: // unused
        case 57: // unused
        case 61: // unused
            decode_unusable(outbuf, n, pc, op);
            break;
        case 2:
            decode_srl(outbuf, n, pc, op);
            break;
        case 3:
            decode_sra(outbuf, n, pc, op);
            break;
        case 4:
            decode_sllv(outbuf, n, pc, op);
            break;



        case 22: // dsrlv
            decode_dsrlv(outbuf, n, pc, op);
            break;

        case 23: // dsrav
            decode_dsrav(outbuf, n, pc, op);
            break;

        case 28: // dmult
            decode_dmult(outbuf, n, pc, op);
            break;

        case 29: // dmultu
            decode_dmultu(outbuf, n, pc, op);
            break;

        case 30: // ddiv
            decode_ddiv(outbuf, n, pc, op);
            break;

        case 31: // ddivu
            decode_ddivu(outbuf, n, pc, op);
            break;

        case 44: // dadd
            decode_dadd(outbuf, n, pc, op);
            break;

        case 45: // daddu
            decode_daddu(outbuf, n, pc, op);
            break;

        case 46: // dsub
            decode_dsub(outbuf, n, pc, op);
            break;

        case 47: // dsubu
            decode_dsubu(outbuf, n, pc, op);
            break;

        case 56: // dsll
            decode_dsll(outbuf, n, pc, op);
            break;

        case 58: // dsrl
            decode_dsrl(outbuf, n, pc, op);
            break;

        case 59: // dsra
            decode_dsra(outbuf, n, pc, op);
            break;

        case 60: // dsll32
            decode_dsll32(outbuf, n, pc, op);
            break;

        case 62: // dsrl32
            decode_dsrl32(outbuf, n, pc, op);
            break;

        case 63: // dsra32
            decode_dsra32(outbuf, n, pc, op);
            break;



        case 6:
            decode_srlv(outbuf, n, pc, op);
            break;
        case 7:
            decode_srav(outbuf, n, pc, op);
            break;
        case 8:
            decode_jr(outbuf, n, pc, op);
            break;
        case 9:
            decode_jalr(outbuf, n, pc, op);
            break;
        case 10:
            decode_movz(outbuf, n, pc, op);
            break;
        case 11:
            decode_movn(outbuf, n, pc, op);
            break;
        case 12:
            decode_syscall(outbuf, n, pc, op);
            break;
        case 13:
            decode_break(outbuf, n, pc, op);
            break;
        case 15:
            decode_sync(outbuf, n, pc, op);
            break;
        case 16:
            decode_mfhi(outbuf, n, pc, op);
            break;
        case 17:
            decode_mthi(outbuf, n, pc, op);
            break;
        case 18:
            decode_mflo(outbuf, n, pc, op);
            break;
        case 19:
            decode_mtlo(outbuf, n, pc, op);
            break;
        case 20: // dsllv
            decode_dsllv(outbuf, n, pc, op);
            break;
        case 24:
            decode_mult(outbuf, n, pc, op);
            break;
        case 25:
            decode_multu(outbuf, n, pc, op);
            break;
        case 26:
            decode_div(outbuf, n, pc, op);
            break;
        case 27:
            decode_divu(outbuf, n, pc, op);
            break;
        case 32:
            decode_add(outbuf, n, pc, op);
            break;
        case 33:
            decode_addu(outbuf, n, pc, op);
            break;
        case 34:
            decode_sub(outbuf, n, pc, op);
            break;
        case 35:
            decode_subu(outbuf, n, pc, op);
            break;
        case 36:
            decode_and(outbuf, n, pc, op);
            break;
        case 37:
            decode_or(outbuf, n, pc, op);
            break;
        case 38:
            decode_xor(outbuf, n, pc, op);
            break;
        case 39:
            decode_nor(outbuf, n, pc, op);
            break;
        case 42:
            decode_slt(outbuf, n, pc, op);
            break;
        case 43:
            decode_sltu(outbuf, n, pc, op);
            break;
        case 48:
            decode_tge(outbuf, n, pc, op);
            break;
        case 49:
            decode_tgeu(outbuf, n, pc, op);
            break;
        case 50:
            decode_tlt(outbuf, n, pc, op);
            break;
        case 51:
            decode_tltu(outbuf, n, pc, op);
            break;
        case 52:
            decode_teq(outbuf, n, pc, op);
            break;
        case 54:
            decode_tne(outbuf, n, pc, op);
            break;
        default:
            /* unreachable */
            abort();
    }
}

static void decode_REGIMM(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    switch (getrt(op))
    {
        case 0:
            decode_bltz(outbuf, n, pc, op);
            break;
        case 1:
            decode_bgez(outbuf, n, pc, op);
            break;
        case 2:
            decode_bltzl(outbuf, n, pc, op);
            break;
        case 3:
            decode_bgezl(outbuf, n, pc, op);
            break;
        case 4:
        case 5:
        case 6:
        case 7:
        case 13:
        case 15:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24: // mtsab
        case 25: // mtsah
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 31:
            decode_reserved(outbuf, n, pc, op);
            break;
        case 8:
            decode_tgei(outbuf, n, pc, op);
            break;
        case 9:
            decode_tgeiu(outbuf, n, pc, op);
            break;
        case 10:
            decode_tlti(outbuf, n, pc, op);
            break;
        case 11:
            decode_tltiu(outbuf, n, pc, op);
            break;
        case 12:
            decode_teqi(outbuf, n, pc, op);
            break;
        case 14:
            decode_tnei(outbuf, n, pc, op);
            break;
        case 16:
            decode_bltzal(outbuf, n, pc, op);
            break;
        case 17:
            decode_bgezal(outbuf, n, pc, op);
            break;
        case 18:
            decode_bltzall(outbuf, n, pc, op);
            break;
        case 19:
            decode_bgezall(outbuf, n, pc, op);
            break;
        default:
            /* unreachable */
            abort();
    }
}

static void decode_COP0(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    switch (getrs(op))
    {
        case 0:
            decode_mfc0(outbuf, n, pc, op);
            break;


        case 1: // dmfc0
            decode_dmfc0(outbuf, n, pc, op);
            break;

        case 5: // dmtc0
            decode_dmtc0(outbuf, n, pc, op);
            break;



        case 2:
        case 3:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:

        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 31:
            decode_unusable(outbuf, n, pc, op);
            break;
        case 4:
            decode_mtc0(outbuf, n, pc, op);
            break;
        case 16:
            decode_COP0FUNCT(outbuf, n, pc, op);
            break;
        default:
            /* unreachable */
            abort();
    }
}

static void decode_COP0FUNCT(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    switch (getfunction(op))
    {
        case 0:
        case 3:
        case 4:
        case 5:
        case 7:
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 33:
        case 34:
        case 35:
        case 36:
        case 37:
        case 38:
        case 39:
        case 40:
        case 41:
        case 42:
        case 43:
        case 44:
        case 45:
        case 46:
        case 47:
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
            decode_unusable(outbuf, n, pc, op);
            break;
        case 1:
            decode_tlbr(outbuf, n, pc, op);
            break;
        case 2:
            decode_tlbwi(outbuf, n, pc, op);
            break;
        case 6:
            decode_tlbwr(outbuf, n, pc, op);
            break;
        case 8:
            decode_tlbp(outbuf, n, pc, op);
            break;
        case 24:
            decode_eret(outbuf, n, pc, op);
            break;
        case 31:
            decode_deret(outbuf, n, pc, op);
            break;
        case 32:
            decode_wait(outbuf, n, pc, op);
            break;
        default:
            /* unreachable */
            abort();
    }
}

static void decode_COP1(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    switch (getrs(op))
    {
        case 0: // mfc1
            decode_mfc1(outbuf, n, pc, op);
            break;

        case 1: // dmfc1
            decode_dmfc1(outbuf, n, pc, op);
            break;

        case 2: // cfc1
            decode_cfc1(outbuf, n, pc, op);
            break;

        case 4: // mtc1
            decode_mtc1(outbuf, n, pc, op);
            break;

        case 5: // dmtc1
            decode_dmtc1(outbuf, n, pc, op);
            break;

        case 6: // ctc1
            decode_ctc1(outbuf, n, pc, op);
            break;

        case 8: // cop1bc
            decode_COP1BC(outbuf, n, pc, op);
            break;
        case 16: // cop1s
            decode_COP1FUNCT(outbuf, n, pc, op, 's');
            break;
        case 17: // cop1d
            decode_COP1FUNCT(outbuf, n, pc, op, 'd');
            break;
        case 20: // cop1w
            decode_COP1FUNCT(outbuf, n, pc, op, 'w');
            break;
        case 21: // cop1l
            decode_COP1FUNCT(outbuf, n, pc, op, 'l');
            break;


        case 3:
        case 7:
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
        case 18:
        case 19:
        case 22:
        case 23:
        case 24:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 31:
        case 32:
        case 33:
        case 34:
        case 35:
        case 36:
        case 37:
        case 38:
        case 39:
        case 40:
        case 41:
        case 42:
        case 43:
        case 44:
        case 45:
        case 46:
        case 47:
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
            decode_unusable(outbuf, n, pc, op);
            break;
        default:
            /* unreachable */
            abort();
    }
}

static void decode_COP1BC(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    switch (getrt(op))
    {
        case 0: // bc1f
            decode_bc1f(outbuf, n, pc, op);
            break;

        case 1: // bc1t
            decode_bc1t(outbuf, n, pc, op);
            break;

        case 2: // bc1fl
            decode_bc1fl(outbuf, n, pc, op);
            break;

        case 3: // bc1tl
            decode_bc1tl(outbuf, n, pc, op);
            break;




        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 31:
        case 32:
        case 33:
        case 34:
        case 35:
        case 36:
        case 37:
        case 38:
        case 39:
        case 40:
        case 41:
        case 42:
        case 43:
        case 44:
        case 45:
        case 46:
        case 47:
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
            decode_unusable(outbuf, n, pc, op);
            break;
        default:
            /* unreachable */
            abort();
    }
}

// the .fmt instructions are all handled weirdly, but very similarly.  because of this, they are all handled here
static void decode_COP1FUNCT(char *outbuf, size_t n, uint32_t pc, uint32_t op, char suffix)
{
    switch (getfunction(op)) // validity check first of all
    {
// the following can't be w or l to replace fmt
        case 0: // add.fmt
        case 1: // sub.fmt
        case 2: // mul.fmt
        case 3: // div.fmt
        case 4: // sqrt.fmt
        case 5: // abs.fmt
        case 6: // mov.fmt
        case 7: // neg.fmt
        case 8: // round.l.fmt
        case 9: // trunc.l.fmt
        case 10: // ceil.l.fmt
        case 11: // floor.l.fmt
        case 12: // round.w.fmt
        case 13: // trunc.w.fmt
        case 14: // ceil.w.fmt
        case 15: // floor.w.fmt
        case 36: // cvt.w.fmt
        case 37: // cvt.l.fmt
        case 48: // c.f.fmt
        case 49: // c.un.fmt
        case 50: // c.eq.fmt
        case 51: // c.ueq.fmt
        case 52: // c.olt.fmt
        case 53: // c.ult.fmt
        case 54: // c.ole.fmt
        case 55: // c.ule.fmt
        case 56: // c.sf.fmt
        case 57: // n.ngle.fmt
        case 58: // c.seq.fmt
        case 59: // c.ngl.fmt
        case 60: // c.lt.fmt
        case 61: // c.nge.fmt
        case 62: // c.le.fmt
        case 63: // c.ngt.fmt
            if (suffix == 'w' || suffix == 'l')
            {
                decode_unusable(outbuf, n, pc, op);
                return;
            }
            break;
        case 32: // cvt.s.fmt
            // can't be s, but yes to w and l
            if (suffix == 's')
            {
                decode_unusable(outbuf, n, pc, op);
                return;
            }
            break;
        case 33: // cvt.d.fmt
            // can't be d, but yes to w and l
            if (suffix == 'd')
            {
                decode_unusable(outbuf, n, pc, op);
                return;
            }
            break;

    }

    switch (getfunction(op))
    {
        case 0: // add.fmt
            decode_add_fmt(outbuf, n, pc, op, suffix);
            break;

        case 1: // sub.fmt
            decode_sub_fmt(outbuf, n, pc, op, suffix);
            break;

        case 2: // mul.fmt
            decode_mul_fmt(outbuf, n, pc, op, suffix);
            break;

        case 3: // div.fmt
            decode_div_fmt(outbuf, n, pc, op, suffix);
            break;

        case 4: // sqrt.fmt
            decode_sqrt_fmt(outbuf, n, pc, op, suffix);
            break;

        case 5: // abs.fmt
            decode_abs_fmt(outbuf, n, pc, op, suffix);
            break;

        case 6: // mov.fmt
            decode_mov_fmt(outbuf, n, pc, op, suffix);
            break;

        case 7: // neg.fmt
            decode_neg_fmt(outbuf, n, pc, op, suffix);
            break;

        case 8: // round.l.fmt
            decode_round_l_fmt(outbuf, n, pc, op, suffix);
            break;

        case 9: // trunc.l.fmt
            decode_trunc_l_fmt(outbuf, n, pc, op, suffix);
            break;

        case 10: // ceil.l.fmt
            decode_ceil_l_fmt(outbuf, n, pc, op, suffix);
            break;

        case 11: // floor.l.fmt
            decode_floor_l_fmt(outbuf, n, pc, op, suffix);
            break;

        case 12: // round.w.fmt
            decode_round_w_fmt(outbuf, n, pc, op, suffix);
            break;

        case 13: // trunc.w.fmt
            decode_trunc_w_fmt(outbuf, n, pc, op, suffix);
            break;

        case 14: // ceil.w.fmt
            decode_ceil_w_fmt(outbuf, n, pc, op, suffix);
            break;

        case 15: // floor.w.fmt
            decode_floor_w_fmt(outbuf, n, pc, op, suffix);
            break;

        case 32: // cvt.s.fmt
            decode_cvt_s_fmt(outbuf, n, pc, op, suffix);
            break;

        case 33: // cvt.d.fmt
            decode_cvt_d_fmt(outbuf, n, pc, op, suffix);
            break;

        case 36: // cvt.w.fmt
            decode_cvt_w_fmt(outbuf, n, pc, op, suffix);
            break;

        case 37: // cvt.l.fmt
            decode_cvt_l_fmt(outbuf, n, pc, op, suffix);
            break;

        case 48: // c.f.fmt
            decode_c_f_fmt(outbuf, n, pc, op, suffix);
            break;

        case 49: // c.un.fmt
            decode_c_un_fmt(outbuf, n, pc, op, suffix);
            break;

        case 50: // c.eq.fmt
            decode_c_eq_fmt(outbuf, n, pc, op, suffix);
            break;

        case 51: // c.ueq.fmt
            decode_c_ueq_fmt(outbuf, n, pc, op, suffix);
            break;

        case 52: // c.olt.fmt
            decode_c_olt_fmt(outbuf, n, pc, op, suffix);
            break;

        case 53: // c.ult.fmt
            decode_c_ult_fmt(outbuf, n, pc, op, suffix);
            break;

        case 54: // c.ole.fmt
            decode_c_ole_fmt(outbuf, n, pc, op, suffix);
            break;

        case 55: // c.ule.fmt
            decode_c_ule_fmt(outbuf, n, pc, op, suffix);
            break;

        case 56: // c.sf.fmt
            decode_c_sf_fmt(outbuf, n, pc, op, suffix);
            break;

        case 57: // n.ngle.fmt
            decode_n_ngle_fmt(outbuf, n, pc, op, suffix);
            break;

        case 58: // c.seq.fmt
            decode_c_seq_fmt(outbuf, n, pc, op, suffix);
            break;

        case 59: // c.ngl.fmt
            decode_c_ngl_fmt(outbuf, n, pc, op, suffix);
            break;

        case 60: // c.lt.fmt
            decode_c_lt_fmt(outbuf, n, pc, op, suffix);
            break;

        case 61: // c.nge.fmt
            decode_c_nge_fmt(outbuf, n, pc, op, suffix);
            break;

        case 62: // c.le.fmt
            decode_c_le_fmt(outbuf, n, pc, op, suffix);
            break;

        case 63: // c.ngt.fmt
            decode_c_ngt_fmt(outbuf, n, pc, op, suffix);
            break;



        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 31:
        case 34:
        case 35:
        case 38:
        case 39:
        case 40:
        case 41:
        case 42:
        case 43:
        case 44:
        case 45:
        case 46:
        case 47:
            decode_unusable(outbuf, n, pc, op);
            break;
        default:
            /* unreachable */
            abort();
    }
}
