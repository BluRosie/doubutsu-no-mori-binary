/*
 * This file contains autogenerated routines for dispatching and disassembling
 * MIPS opcodes.
 *
 * The code has been generated by mipsgen.
 *
 * See scripts/mipsgen.rb for the code generator framework.
 * See codegen/cgen.rb for C specific information.
 */

static char* format_register(uint32_t re)
{
    char* reg;

    switch (re)
    {
        case 0:
            reg = "$zero";
            break;
        case 1:
            reg = "at";
            break;
        case 2:
            reg = "v0";
            break;
        case 3:
            reg = "v1";
            break;
        case 4:
            reg = "a0";
            break;
        case 5:
            reg = "a1";
            break;
        case 6:
            reg = "a2";
            break;
        case 7:
            reg = "a3";
            break;
        case 8:
            reg = "t0";
            break;
        case 9:
            reg = "t1";
            break;
        case 10:
            reg = "t2";
            break;
        case 11:
            reg = "t3";
            break;
        case 12:
            reg = "t4";
            break;
        case 13:
            reg = "t5";
            break;
        case 14:
            reg = "t6";
            break;
        case 15:
            reg = "t7";
            break;
        case 16:
            reg = "s0";
            break;
        case 17:
            reg = "s1";
            break;
        case 18:
            reg = "s2";
            break;
        case 19:
            reg = "s3";
            break;
        case 20:
            reg = "s4";
            break;
        case 21:
            reg = "s5";
            break;
        case 22:
            reg = "s6";
            break;
        case 23:
            reg = "s7";
            break;
        case 24:
            reg = "t8";
            break;
        case 25:
            reg = "t9";
            break;
        case 26:
            reg = "k0";
            break;
        case 27:
            reg = "k1";
            break;
        case 28:
            reg = "gp";
            break;
        case 29:
            reg = "sp";
            break;
        case 30:
            reg = "fp";
            break;
        case 31:
            reg = "ra";
            break;
    }

    return reg;
}

static void decode_j(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (_delay)
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = true;
    if (gettarget(pc,op) >= programbase && gettarget(pc,op) < programbase + filesize)
        snprintf(outbuf,n,"j _%08x",gettarget(pc,op));
    else
        snprintf(outbuf,n,"j 0x%08x",gettarget(pc,op));
}

static void decode_jal(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (_delay)
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = true;
    if (gettarget(pc,op) >= programbase && gettarget(pc,op) < programbase + filesize)
        snprintf(outbuf,n,"jal _%08x",gettarget(pc,op));
    else
        snprintf(outbuf,n,"jal 0x%08x",gettarget(pc,op));
}

static void decode_beq(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (_delay)
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = true;
    if (getbroff(pc,op) >= programbase && getbroff(pc,op) < programbase + filesize)
        snprintf(outbuf,n,"beq %s, %s, _%08x",format_register(getrs(op)),format_register(getrt(op)),getbroff(pc,op));
    else
        snprintf(outbuf,n,"beq %s, %s, 0x%08x",format_register(getrs(op)),format_register(getrt(op)),getbroff(pc,op));
}

static void decode_bne(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (_delay)
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = true;
    if (getbroff(pc,op) >= programbase && getbroff(pc,op) < programbase + filesize)
        snprintf(outbuf,n,"bne %s, %s, _%08x",format_register(getrs(op)),format_register(getrt(op)),getbroff(pc,op));
    else
        snprintf(outbuf,n,"bne %s, %s, 0x%08x",format_register(getrs(op)),format_register(getrt(op)),getbroff(pc,op));
}

static void decode_blez(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc1f0000, 0x18000000)) || _delay)
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = true;
    if (getbroff(pc,op) >= programbase && getbroff(pc,op) < programbase + filesize)
        snprintf(outbuf,n,"blez %s, _%08x",format_register(getrs(op)),getbroff(pc,op));
    else
        snprintf(outbuf,n,"blez %s, 0x%08x",format_register(getrs(op)),getbroff(pc,op));
}

static void decode_bgtz(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc1f0000, 0x1c000000)) || _delay)
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = true;
    if (getbroff(pc,op) >= programbase && getbroff(pc,op) < programbase + filesize)
        snprintf(outbuf,n,"bgtz %s, _%08x",format_register(getrs(op)),getbroff(pc,op));
    else
        snprintf(outbuf,n,"bgtz %s, 0x%08x",format_register(getrs(op)),getbroff(pc,op));
}

static void decode_addi(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"addi %s, %s, 0x%x",format_register(getrt(op)),format_register(getrs(op)),getsimm(op));
}

static void decode_addiu(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"addiu %s, %s, 0x%x",format_register(getrt(op)),format_register(getrs(op)),getsimm(op));
}

static void decode_slti(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"slti %s, %s, 0x%x",format_register(getrt(op)),format_register(getrs(op)),getsimm(op));
}

static void decode_sltiu(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"sltiu %s, %s, 0x%x",format_register(getrt(op)),format_register(getrs(op)),getsimm(op));
}

static void decode_andi(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"andi %s, %s, 0x%x",format_register(getrt(op)),format_register(getrs(op)),getimm(op));
}

static void decode_ori(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"ori %s, %s, 0x%x",format_register(getrt(op)),format_register(getrs(op)),getimm(op));
}

static void decode_xori(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"xori %s, %s, 0x%x",format_register(getrt(op)),format_register(getrs(op)),getimm(op));
}

static void decode_lui(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffe00000, 0x3c000000)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"lui %s, 0x%x",format_register(getrt(op)),getimm(op));
}

static void decode_beql(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (_delay)
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = true;
    if (getbroff(pc,op) >= programbase && getbroff(pc,op) < programbase + filesize)
        snprintf(outbuf,n,"beql %s, %s, _%08x",format_register(getrs(op)),format_register(getrt(op)),getbroff(pc,op));
    else
        snprintf(outbuf,n,"beql %s, %s, 0x%08x",format_register(getrs(op)),format_register(getrt(op)),getbroff(pc,op));
}

static void decode_bnel(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (_delay)
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = true;
    if (getbroff(pc,op) >= programbase && getbroff(pc,op) < programbase + filesize)
        snprintf(outbuf,n,"bnel %s, %s, _%08x",format_register(getrs(op)),format_register(getrt(op)),getbroff(pc,op));
    else
        snprintf(outbuf,n,"bnel %s, %s, 0x%08x",format_register(getrs(op)),format_register(getrt(op)),getbroff(pc,op));
}

static void decode_blezl(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc1f0000, 0x58000000)) || _delay)
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = true;
    if (getbroff(pc,op) >= programbase && getbroff(pc,op) < programbase + filesize)
        snprintf(outbuf,n,"blezl %s, _%08x",format_register(getrs(op)),getbroff(pc,op));
    else
        snprintf(outbuf,n,"blezl %s, 0x%08x",format_register(getrs(op)),getbroff(pc,op));
}

static void decode_bgtzl(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc1f0000, 0x5c000000)) || _delay)
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = true;
    if (getbroff(pc,op) >= programbase && getbroff(pc,op) < programbase + filesize)
        snprintf(outbuf,n,"bgtzl %s, _%08x",format_register(getrs(op)),getbroff(pc,op));
    else
        snprintf(outbuf,n,"bgtzl %s, 0x%08x",format_register(getrs(op)),getbroff(pc,op));
}

static void decode_lb(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"lb %s, 0x%x(%s)",format_register(getrt(op)),getoffset(op),format_register(getbase(op)));
}

static void decode_lh(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"lh %s, 0x%x(%s)",format_register(getrt(op)),getoffset(op),format_register(getbase(op)));
}

static void decode_lwl(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"lwl %s, 0x%x(%s)",format_register(getrt(op)),getoffset(op),format_register(getbase(op)));
}

static void decode_lw(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"lw %s, 0x%x(%s)",format_register(getrt(op)),getoffset(op),format_register(getbase(op)));
}

static void decode_lbu(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"lbu %s, 0x%x(%s)",format_register(getrt(op)),getoffset(op),format_register(getbase(op)));
}

static void decode_lhu(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"lhu %s, 0x%x(%s)",format_register(getrt(op)),getoffset(op),format_register(getbase(op)));
}

static void decode_lwr(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"lwr %s, 0x%x(%s)",format_register(getrt(op)),getoffset(op),format_register(getbase(op)));
}

static void decode_sb(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"sb %s, 0x%x(%s)",format_register(getrt(op)),getoffset(op),format_register(getbase(op)));
}

static void decode_sh(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"sh %s, 0x%x(%s)",format_register(getrt(op)),getoffset(op),format_register(getbase(op)));
}

static void decode_swl(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"swl %s, 0x%x(%s)",format_register(getrt(op)),getoffset(op),format_register(getbase(op)));
}

static void decode_sw(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"sw %s, 0x%x(%s)",format_register(getrt(op)),getoffset(op),format_register(getbase(op)));
}

static void decode_swr(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"swr %s, 0x%x(%s)",format_register(getrt(op)),getoffset(op),format_register(getbase(op)));
}

static void decode_cache(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"cache 0x%x, 0x%x(%s)",getcacheop(op),getoffset(op),format_register(getbase(op)));
}

static void decode_ll(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"ll %s, 0x%x(%s)",format_register(getrt(op)),getoffset(op),format_register(getbase(op)));
}

static void decode_pref(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    decode_illegal(outbuf, n, pc, op);

    // snprintf(outbuf,n,"pref 0x%x, 0x%x(%s)",getprefhint(op),getoffset(op),format_register(getbase(op)));
}

static void decode_sc(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"sc %s, 0x%x(%s)",format_register(getrt(op)),getoffset(op),format_register(getbase(op)));
}

static void decode_sll(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffe0003f, 0x00000000)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"sll %s, %s, 0x%x",format_register(getrd(op)),format_register(getrt(op)),getsa(op));
}

static void decode_srl(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffe0003f, 0x00000002)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"srl %s, %s, 0x%x",format_register(getrd(op)),format_register(getrt(op)),getsa(op));
}

static void decode_sra(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffe0003f, 0x00000003)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"sra %s, %s, 0x%x",format_register(getrd(op)),format_register(getrt(op)),getsa(op));
}

static void decode_sllv(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 0x00000004)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"sllv %s, %s, %s",format_register(getrd(op)),format_register(getrt(op)),format_register(getrs(op)));
}

static void decode_srlv(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 0x00000006)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"srlv %s, %s, %s",format_register(getrd(op)),format_register(getrt(op)),format_register(getrs(op)));
}

static void decode_srav(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 0x00000007)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"srav %s, %s, %s",format_register(getrd(op)),format_register(getrt(op)),format_register(getrs(op)));
}

static void decode_jr(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc1fffff, 0x00000008)) || _delay)
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = true;
    snprintf(outbuf,n,"jr %s",format_register(getrs(op)));
}

static void decode_jalr(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc1f07ff, 0x00000009) && check_jalr(getrs(op), getrd(op)))
     || _delay)
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = true;
    snprintf(outbuf,n,"jalr %s, %s", format_register(getrs(op)), format_register(getrd(op)));
}

static void decode_movz(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    //if (!(check_opcode(op, 0xfc0007ff, 0x0000000a)))
    //{
        decode_illegal(outbuf, n, pc, op);
    //    return;
    //}

    //snprintf(outbuf,n,"movz %s, %s, %s",format_register(getrd(op)),format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_movn(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    //if (!(check_opcode(op, 0xfc0007ff, 0x0000000b)))
    //{
        decode_illegal(outbuf, n, pc, op);
    //    return;
    //}

    //snprintf(outbuf,n,"movn %s, %s, %s",format_register(getrd(op)),format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_syscall(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (_delay)
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    snprintf(outbuf,n,"syscall 0x%x",getsyscode(op));
}

static void decode_break(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (_delay)
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    snprintf(outbuf,n,"break 0x%x",getsyscode(op));
}

static void decode_sync(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfffff83f, 0x0000000f))
     || (op & 0xfffffff0)) // if anything but the last 4 bits is filled, the sync cmd is illegal to preserve data
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"sync");
}

static void decode_mfhi(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffff07ff, 0x00000010)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"mfhi %s",format_register(getrd(op)));
}

static void decode_mthi(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc1fffff, 0x00000011)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"mthi %s",format_register(getrs(op)));
}

static void decode_mflo(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffff07ff, 0x00000012)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"mflo %s",format_register(getrd(op)));
}

static void decode_mtlo(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc1fffff, 0x00000013)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"mtlo %s",format_register(getrs(op)));
}

static void decode_mult(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc00ffff, 0x00000018)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"mult %s, %s",format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_multu(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc00ffff, 0x00000019)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"multu %s, %s",format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_div(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc00ffff, 0x0000001a)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"div %s, %s",format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_divu(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc00ffff, 0x0000001b)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"divu %s, %s",format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_add(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 0x00000020)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"add %s, %s, %s",format_register(getrd(op)),format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_addu(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 0x00000021)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"addu %s, %s, %s",format_register(getrd(op)),format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_sub(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 0x00000022)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"sub %s, %s, %s",format_register(getrd(op)),format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_subu(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 0x00000023)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"subu %s, %s, %s",format_register(getrd(op)),format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_and(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 0x00000024)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"and %s, %s, %s",format_register(getrd(op)),format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_or(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 0x00000025)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"or %s, %s, %s",format_register(getrd(op)),format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_xor(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 0x00000026)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"xor %s, %s, %s",format_register(getrd(op)),format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_nor(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 0x00000027)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"nor %s, %s, %s",format_register(getrd(op)),format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_slt(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 0x0000002a)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"slt %s, %s, %s",format_register(getrd(op)),format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_sltu(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 0x0000002b)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"sltu %s, %s, %s",format_register(getrd(op)),format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_tge(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"tge %s, %s, 0x%x",format_register(getrs(op)),format_register(getrt(op)),gettrapcode(op));
}

static void decode_tgeu(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"tgeu %s, %s, 0x%x",format_register(getrs(op)),format_register(getrt(op)),gettrapcode(op));
}

static void decode_tlt(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"tlt %s, %s, 0x%x",format_register(getrs(op)),format_register(getrt(op)),gettrapcode(op));
}

static void decode_tltu(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"tltu %s, %s, 0x%x",format_register(getrs(op)),format_register(getrt(op)),gettrapcode(op));
}

static void decode_teq(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"teq %s, %s, 0x%x",format_register(getrs(op)),format_register(getrt(op)),gettrapcode(op));
}

static void decode_tne(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"tne %s, %s, 0x%x",format_register(getrs(op)),format_register(getrt(op)),gettrapcode(op));
}

static void decode_madd(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    //if (!(check_opcode(op, 0xfc00ffff, 0x70000000)))
    //{
        decode_illegal(outbuf, n, pc, op);
    //    return;
    //}

    //snprintf(outbuf,n,"madd %s, %s",format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_maddu(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    //if (!(check_opcode(op, 0xfc00ffff, 0x70000001)))
    //{
        decode_illegal(outbuf, n, pc, op);
    //    return;
    //}

    //snprintf(outbuf,n,"maddu %s, %s",format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_mul(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 0x70000002)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"mul %s, %s, %s",format_register(getrd(op)),format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_msub(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    //if (!(check_opcode(op, 0xfc00ffff, 0x70000004)))
    //{
        decode_illegal(outbuf, n, pc, op);
    //    return;
    //}

    //snprintf(outbuf,n,"msub %s, %s",format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_msubu(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    //if (!(check_opcode(op, 0xfc00ffff, 0x70000005)))
    //{
        decode_illegal(outbuf, n, pc, op);
    //    return;
    //}

    //snprintf(outbuf,n,"msubu %s, %s",format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_clz(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 0x70000020)&&check_cl(getrt(op), getrd(op))))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"clz %s, %s",format_register(getrd(op)),format_register(getrs(op)));
}

static void decode_clo(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 0x70000021)&&check_cl(getrt(op), getrd(op))))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"clo %s, %s",format_register(getrd(op)),format_register(getrs(op)));
}

static void decode_sdbbp(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    decode_illegal(outbuf, n, pc, op);
    //snprintf(outbuf,n,"sdbbp 0x%x",getsyscode(op));
}

static void decode_bltz(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (_delay)
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = true;
    if (getbroff(pc,op) >= programbase && getbroff(pc,op) < programbase + filesize)
        snprintf(outbuf,n,"bltz %s, _%08x",format_register(getrs(op)),getbroff(pc,op));
    else
        snprintf(outbuf,n,"bltz %s, 0x%08x",format_register(getrs(op)),getbroff(pc,op));
}

static void decode_bgez(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (_delay)
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = true;
    if (getbroff(pc,op) >= programbase && getbroff(pc,op) < programbase + filesize)
        snprintf(outbuf,n,"bgez %s, _%08x",format_register(getrs(op)),getbroff(pc,op));
    else
        snprintf(outbuf,n,"bgez %s, 0x%08x",format_register(getrs(op)),getbroff(pc,op));
}

static void decode_bltzl(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (_delay)
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = true;
    if (getbroff(pc,op) >= programbase && getbroff(pc,op) < programbase + filesize)
        snprintf(outbuf,n,"bltzl %s, _%08x",format_register(getrs(op)),getbroff(pc,op));
    else
        snprintf(outbuf,n,"bltzl %s, 0x%08x",format_register(getrs(op)),getbroff(pc,op));
}

static void decode_bgezl(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (_delay)
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = true;
    if (getbroff(pc,op) >= programbase && getbroff(pc,op) < programbase + filesize)
        snprintf(outbuf,n,"bgezl %s, _%08x",format_register(getrs(op)),getbroff(pc,op));
    else
        snprintf(outbuf,n,"bgezl %s, 0x%08x",format_register(getrs(op)),getbroff(pc,op));
}

static void decode_tgei(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"tgei %s, %d",format_register(getrs(op)),getsimm(op));
}

static void decode_tgeiu(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"tgeiu %s, %d",format_register(getrs(op)),getsimm(op));
}

static void decode_tlti(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"tlti %s, %d",format_register(getrs(op)),getsimm(op));
}

static void decode_tltiu(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"tltiu %s, %d",format_register(getrs(op)),getsimm(op));
}

static void decode_teqi(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"teqi %s, %d",format_register(getrs(op)),getsimm(op));
}

static void decode_tnei(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    _delay = false;
    snprintf(outbuf,n,"tnei %s, %d",format_register(getrs(op)),getsimm(op));
}

static void decode_bltzal(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (_delay)
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = true;
    if (getbroff(pc,op) >= programbase && getbroff(pc,op) < programbase + filesize)
        snprintf(outbuf,n,"bltzal %s, _%08x",format_register(getrs(op)),getbroff(pc,op));
    else
        snprintf(outbuf,n,"bltzal %s, 0x%08x",format_register(getrs(op)),getbroff(pc,op));
}

static void decode_bgezal(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (_delay)
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = true;
    if (getbroff(pc,op) >= programbase && getbroff(pc,op) < programbase + filesize)
        snprintf(outbuf,n,"bgezal %s, _%08x",format_register(getrs(op)),getbroff(pc,op));
    else
        snprintf(outbuf,n,"bgezal %s, 0x%08x",format_register(getrs(op)),getbroff(pc,op));
}

static void decode_bltzall(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (_delay)
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = true;
    if (getbroff(pc,op) >= programbase && getbroff(pc,op) < programbase + filesize)
        snprintf(outbuf,n,"bltzall %s, _%08x",format_register(getrs(op)),getbroff(pc,op));
    else
        snprintf(outbuf,n,"bltzall %s, 0x%08x",format_register(getrs(op)),getbroff(pc,op));
}

static void decode_bgezall(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (_delay)
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = true;
    if (getbroff(pc,op) >= programbase && getbroff(pc,op) < programbase + filesize)
        snprintf(outbuf,n,"bgezall %s, _%08x",format_register(getrs(op)),getbroff(pc,op));
    else
        snprintf(outbuf,n,"bgezall %s, 0x%08x",format_register(getrs(op)),getbroff(pc,op));
}

static void decode_mfc0(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffe007f8, 0x40000000))
     || (op & 0x03E007ff)) // those 5 bits and the last 11 bits are always 0
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"mfc0 %s, $%d",format_register(getrt(op)),getrd(op));
}

static void decode_mtc0(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffe007f8, 0x40800000))
     || (op & 0x036007ff)) // same case as mfc0
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"mtc0 %s, $%d",format_register(getrt(op)),getrd(op));
}

static void decode_tlbr(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffffffff, 0x42000001)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"tlbr");
}

static void decode_tlbwi(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffffffff, 0x42000002)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"tlbwi");
}

static void decode_tlbwr(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffffffff, 0x42000006)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"tlbwr");
}

static void decode_tlbp(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffffffff, 0x42000008)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"tlbp");
}

static void decode_eret(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffffffff, 0x42000018)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"eret");
}

static void decode_deret(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffffffff, 0x4200001f)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"deret");
}

static void decode_wait(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    decode_illegal(outbuf, n, pc, op);
    //snprintf(outbuf,n,"wait 0x%x",getwaitcode(op));
}




// all this shit is new because loadzero left a shit ton unfinished

static void decode_dsllv(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 0x00000007)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    _delay = false;
    snprintf(outbuf,n,"dsllv %s, %s, %s",format_register(getrd(op)),format_register(getrt(op)),format_register(getrs(op)));
}



static void decode_OPCODE(char *outbuf, size_t n, uint32_t pc, uint32_t op);
static void decode_SPECIAL(char *outbuf, size_t n, uint32_t pc, uint32_t op);
static void decode_REGIMM(char *outbuf, size_t n, uint32_t pc, uint32_t op);
static void decode_COP0(char *outbuf, size_t n, uint32_t pc, uint32_t op);
static void decode_COP0FUNCT(char *outbuf, size_t n, uint32_t pc, uint32_t op);
static void decode_COP1(char *outbuf, size_t n, uint32_t pc, uint32_t op);
static void decode_COP1BC(char *outbuf, size_t n, uint32_t pc, uint32_t op);
static void decode_COP1FUNCT(char *outbuf, size_t n, uint32_t pc, uint32_t op, char suffix);


static void decode_OPCODE(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    switch (getopcode(op))
    {
        case 0:
            decode_SPECIAL(outbuf, n, pc, op);
            break;
        case 1:
            decode_REGIMM(outbuf, n, pc, op);
            break;
        case 2:
            decode_j(outbuf, n, pc, op);
            break;
        case 3:
            decode_jal(outbuf, n, pc, op);
            break;
        case 4:
            decode_beq(outbuf, n, pc, op);
            break;
        case 5:
            decode_bne(outbuf, n, pc, op);
            break;
        case 6:
            decode_blez(outbuf, n, pc, op);
            break;
        case 7:
            decode_bgtz(outbuf, n, pc, op);
            break;
        case 8:
            decode_addi(outbuf, n, pc, op);
            break;
        case 9:
            decode_addiu(outbuf, n, pc, op);
            break;
        case 10:
            decode_slti(outbuf, n, pc, op);
            break;
        case 11:
            decode_sltiu(outbuf, n, pc, op);
            break;
        case 12:
            decode_andi(outbuf, n, pc, op);
            break;
        case 13:
            decode_ori(outbuf, n, pc, op);
            break;
        case 14:
            decode_xori(outbuf, n, pc, op);
            break;
        case 15:
            decode_lui(outbuf, n, pc, op);
            break;
        case 16:
            decode_COP0(outbuf, n, pc, op);
            break;
        case 17: // cop1 - floating point
            decode_COP1(outbuf, n, pc, op);
            break;
        case 18: // cop2 - rsp/psx only
        case 19: // unused
        case 28: // unused
        case 29: // unused
        case 30: // lq - ps2 only
        case 31: // sq - ps2 only
        case 50: // lv.s - ps2 only
        case 54: // lv.q - ps2 only
        case 58: // sv.s - ps2 only
        case 59: // unused
        case 62: // sv.q - ps2 only
            decode_unusable(outbuf, n, pc, op);
            break;
        case 20:
            decode_beql(outbuf, n, pc, op);
            break;
        case 21:
            decode_bnel(outbuf, n, pc, op);
            break;
        case 22:
            decode_blezl(outbuf, n, pc, op);
            break;
        case 23:
            decode_bgtzl(outbuf, n, pc, op);
            break;

        case 24: // daddi/dsubi
        case 25: // daddiu/dsubiu
        case 26: // ldl
        case 27: // ldr

        case 39: // lwu

        case 44: // sdl
        case 45: // sdr

        case 49: // lwc1

        case 52: // lld
        case 53: // ldc1

        case 55: // ld

        case 57: // swc1

        case 60: // scd
        case 61: // sdc1

        case 63: // sd



            decode_reserved(outbuf, n, pc, op);
            break;
        case 32:
            decode_lb(outbuf, n, pc, op);
            break;
        case 33:
            decode_lh(outbuf, n, pc, op);
            break;
        case 34:
            decode_lwl(outbuf, n, pc, op);
            break;
        case 35:
            decode_lw(outbuf, n, pc, op);
            break;
        case 36:
            decode_lbu(outbuf, n, pc, op);
            break;
        case 37:
            decode_lhu(outbuf, n, pc, op);
            break;
        case 38:
            decode_lwr(outbuf, n, pc, op);
            break;
        case 40:
            decode_sb(outbuf, n, pc, op);
            break;
        case 41:
            decode_sh(outbuf, n, pc, op);
            break;
        case 42:
            decode_swl(outbuf, n, pc, op);
            break;
        case 43:
            decode_sw(outbuf, n, pc, op);
            break;
        case 46:
            decode_swr(outbuf, n, pc, op);
            break;
        case 47:
            decode_cache(outbuf, n, pc, op);
            break;
        case 48:
            decode_ll(outbuf, n, pc, op);
            break;
        case 51:
            decode_pref(outbuf, n, pc, op);
            break;
        case 56:
            decode_sc(outbuf, n, pc, op);
            break;
        default:
            /* unreachable */
            abort();
    }
}

static void decode_SPECIAL(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    switch (getfunction(op))
    {
        case 0:
            decode_sll(outbuf, n, pc, op);
            break;
        case 1: // unused
        case 5: // unused
        case 14: // unused
        case 21: // unused
        case 40: // mfsa
        case 41: // mtsa
        case 53: // unused
        case 55: // unused
        case 57: // unused
        case 61: // unused
            decode_unusable(outbuf, n, pc, op);
            break;
        case 2:
            decode_srl(outbuf, n, pc, op);
            break;
        case 3:
            decode_sra(outbuf, n, pc, op);
            break;
        case 4:
            decode_sllv(outbuf, n, pc, op);
            break;



        case 22: // dsrlv
        case 23: // dsrav

        case 28: // dmult
        case 29: // dmultu
        case 30: // ddiv
        case 31: // ddivu


        case 44: // dadd
        case 45: // daddu
        case 46: // dsub
        case 47: // dsubu

        case 56: // dsll

        case 58: // dsrl
        case 59: // dsra
        case 60: // dsll32

        case 62: // dsrl32
        case 63: // dsra32



            decode_reserved(outbuf, n, pc, op);
            break;
        case 6:
            decode_srlv(outbuf, n, pc, op);
            break;
        case 7:
            decode_srav(outbuf, n, pc, op);
            break;
        case 8:
            decode_jr(outbuf, n, pc, op);
            break;
        case 9:
            decode_jalr(outbuf, n, pc, op);
            break;
        case 10:
            decode_movz(outbuf, n, pc, op);
            break;
        case 11:
            decode_movn(outbuf, n, pc, op);
            break;
        case 12:
            decode_syscall(outbuf, n, pc, op);
            break;
        case 13:
            decode_break(outbuf, n, pc, op);
            break;
        case 15:
            decode_sync(outbuf, n, pc, op);
            break;
        case 16:
            decode_mfhi(outbuf, n, pc, op);
            break;
        case 17:
            decode_mthi(outbuf, n, pc, op);
            break;
        case 18:
            decode_mflo(outbuf, n, pc, op);
            break;
        case 19:
            decode_mtlo(outbuf, n, pc, op);
            break;
        case 20: // dsllv
            decode_dsllv(outbuf, n, pc, op);
            break;
        case 24:
            decode_mult(outbuf, n, pc, op);
            break;
        case 25:
            decode_multu(outbuf, n, pc, op);
            break;
        case 26:
            decode_div(outbuf, n, pc, op);
            break;
        case 27:
            decode_divu(outbuf, n, pc, op);
            break;
        case 32:
            decode_add(outbuf, n, pc, op);
            break;
        case 33:
            decode_addu(outbuf, n, pc, op);
            break;
        case 34:
            decode_sub(outbuf, n, pc, op);
            break;
        case 35:
            decode_subu(outbuf, n, pc, op);
            break;
        case 36:
            decode_and(outbuf, n, pc, op);
            break;
        case 37:
            decode_or(outbuf, n, pc, op);
            break;
        case 38:
            decode_xor(outbuf, n, pc, op);
            break;
        case 39:
            decode_nor(outbuf, n, pc, op);
            break;
        case 42:
            decode_slt(outbuf, n, pc, op);
            break;
        case 43:
            decode_sltu(outbuf, n, pc, op);
            break;
        case 48:
            decode_tge(outbuf, n, pc, op);
            break;
        case 49:
            decode_tgeu(outbuf, n, pc, op);
            break;
        case 50:
            decode_tlt(outbuf, n, pc, op);
            break;
        case 51:
            decode_tltu(outbuf, n, pc, op);
            break;
        case 52:
            decode_teq(outbuf, n, pc, op);
            break;
        case 54:
            decode_tne(outbuf, n, pc, op);
            break;
        default:
            /* unreachable */
            abort();
    }
}

static void decode_REGIMM(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    switch (getrt(op))
    {
        case 0:
            decode_bltz(outbuf, n, pc, op);
            break;
        case 1:
            decode_bgez(outbuf, n, pc, op);
            break;
        case 2:
            decode_bltzl(outbuf, n, pc, op);
            break;
        case 3:
            decode_bgezl(outbuf, n, pc, op);
            break;
        case 4:
        case 5:
        case 6:
        case 7:
        case 13:
        case 15:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24: // mtsab
        case 25: // mtsah
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 31:
            decode_reserved(outbuf, n, pc, op);
            break;
        case 8:
            decode_tgei(outbuf, n, pc, op);
            break;
        case 9:
            decode_tgeiu(outbuf, n, pc, op);
            break;
        case 10:
            decode_tlti(outbuf, n, pc, op);
            break;
        case 11:
            decode_tltiu(outbuf, n, pc, op);
            break;
        case 12:
            decode_teqi(outbuf, n, pc, op);
            break;
        case 14:
            decode_tnei(outbuf, n, pc, op);
            break;
        case 16:
            decode_bltzal(outbuf, n, pc, op);
            break;
        case 17:
            decode_bgezal(outbuf, n, pc, op);
            break;
        case 18:
            decode_bltzall(outbuf, n, pc, op);
            break;
        case 19:
            decode_bgezall(outbuf, n, pc, op);
            break;
        default:
            /* unreachable */
            abort();
    }
}

static void decode_COP0(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    switch (getrs(op))
    {
        case 0:
            decode_mfc0(outbuf, n, pc, op);
            break;


        case 1: // dmfc0
        case 5: // dmtc0


        case 2:
        case 3:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:

        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 31:
            decode_unusable(outbuf, n, pc, op);
            break;
        case 4:
            decode_mtc0(outbuf, n, pc, op);
            break;
        case 16:
            decode_COP0FUNCT(outbuf, n, pc, op);
            break;
        default:
            /* unreachable */
            abort();
    }
}

static void decode_COP0FUNCT(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    switch (getfunction(op))
    {
        case 0:
        case 3:
        case 4:
        case 5:
        case 7:
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 33:
        case 34:
        case 35:
        case 36:
        case 37:
        case 38:
        case 39:
        case 40:
        case 41:
        case 42:
        case 43:
        case 44:
        case 45:
        case 46:
        case 47:
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
            decode_unusable(outbuf, n, pc, op);
            break;
        case 1:
            decode_tlbr(outbuf, n, pc, op);
            break;
        case 2:
            decode_tlbwi(outbuf, n, pc, op);
            break;
        case 6:
            decode_tlbwr(outbuf, n, pc, op);
            break;
        case 8:
            decode_tlbp(outbuf, n, pc, op);
            break;
        case 24:
            decode_eret(outbuf, n, pc, op);
            break;
        case 31:
            decode_deret(outbuf, n, pc, op);
            break;
        case 32:
            decode_wait(outbuf, n, pc, op);
            break;
        default:
            /* unreachable */
            abort();
    }
}

static void decode_COP1(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    switch (getrs(op))
    {
        case 0: // mfc1
        case 1: // dmfc1
        case 2: // cfc1
        case 4: // mtc1
        case 5: // dmtc1
        case 6: // ctc1
        case 8: // cop1bc
            decode_COP1BC(outbuf, n, pc, op);
            break;
        case 16: // cop1s
            decode_COP1FUNCT(outbuf, n, pc, op, 's');
            break;
        case 17: // cop1d
            decode_COP1FUNCT(outbuf, n, pc, op, 'd');
            break;
        case 20: // cop1w
            decode_COP1FUNCT(outbuf, n, pc, op, 'w');
            break;
        case 21: // cop1l
            decode_COP1FUNCT(outbuf, n, pc, op, 'l');
            break;


        case 3:
        case 7:
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
        case 18:
        case 19:
        case 22:
        case 23:
        case 24:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 31:
        case 32:
        case 33:
        case 34:
        case 35:
        case 36:
        case 37:
        case 38:
        case 39:
        case 40:
        case 41:
        case 42:
        case 43:
        case 44:
        case 45:
        case 46:
        case 47:
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
            decode_unusable(outbuf, n, pc, op);
            break;
        default:
            /* unreachable */
            abort();
    }
}

static void decode_COP1BC(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    switch (getrt(op))
    {
        case 0: // bc1f
        case 1: // bc1t
        case 2: // bc1fl
        case 3: // bc1tl



        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 31:
        case 32:
        case 33:
        case 34:
        case 35:
        case 36:
        case 37:
        case 38:
        case 39:
        case 40:
        case 41:
        case 42:
        case 43:
        case 44:
        case 45:
        case 46:
        case 47:
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
            decode_unusable(outbuf, n, pc, op);
            break;
        default:
            /* unreachable */
            abort();
    }
}

// the .fmt instructions are all handled weirdly, but very similarly.  because of this, they are all handled here
static void decode_COP1FUNCT(char *outbuf, size_t n, uint32_t pc, uint32_t op, char suffix)
{
    switch (getfunction(op)) // validity check first of all
    {
// the following can't be w or l to replace fmt
        case 0: // add.fmt
        case 1: // sub.fmt
        case 2: // mul.fmt
        case 3: // div.fmt
        case 4: // sqrt.fmt
        case 5: // abs.fmt
        case 6: // mov.fmt
        case 7: // neg.fmt
        case 8: // round.l.fmt
        case 9: // trunc.l.fmt
        case 10: // ceil.l.fmt
        case 11: // floor.l.fmt
        case 12: // round.w.fmt
        case 13: // trunc.w.fmt
        case 14: // ceil.w.fmt
        case 15: // floor.w.fmt
        case 36: // cvt.w.fmt
        case 37: // cvt.l.fmt
        case 48: // c.f.fmt
        case 49: // c.un.fmt
        case 50: // c.eq.fmt
        case 51: // c.ueq.fmt
        case 52: // c.olt.fmt
        case 53: // c.ult.fmt
        case 54: // c.ole.fmt
        case 55: // c.ule.fmt
        case 56: // c.sf.fmt
        case 57: // n.ngle.fmt
        case 58: // c.seq.fmt
        case 59: // c.ngl.fmt
        case 60: // c.lt.fmt
        case 61: // c.nge.fmt
        case 62: // c.le.fmt
        case 63: // c.ngt.fmt
            if (suffix == 'w' || suffix == 'l')
            {
                decode_unusable(outbuf, n, pc, op);
                return;
            }
            break;
        case 32: // cvt.s.fmt
            // can't be s, but yes to w and l
            if (suffix == 's')
            {
                decode_unusable(outbuf, n, pc, op);
                return;
            }
            break;
        case 33: // cvt.d.fmt
            // can't be d, but yes to w and l
            if (suffix == 'd')
            {
                decode_unusable(outbuf, n, pc, op);
                return;
            }
            break;

    }

    switch (getfunction(op))
    {
// the following can't be w or l to replace fmt
        case 0: // add.fmt
        case 1: // sub.fmt
        case 2: // mul.fmt
        case 3: // div.fmt
        case 4: // sqrt.fmt
        case 5: // abs.fmt
        case 6: // mov.fmt
        case 7: // neg.fmt
        case 8: // round.l.fmt
        case 9: // trunc.l.fmt
        case 10: // ceil.l.fmt
        case 11: // floor.l.fmt
        case 12: // round.w.fmt
        case 13: // trunc.w.fmt
        case 14: // ceil.w.fmt
        case 15: // floor.w.fmt


        case 32: // cvt.s.fmt
            // can't be s, but yes to w and l
        case 33: // cvt.d.fmt
            // can't be d, but yes to w and l

// the following can't be w or l
        case 36: // cvt.w.fmt
        case 37: // cvt.l.fmt


        case 48: // c.f.fmt
        case 49: // c.un.fmt
        case 50: // c.eq.fmt
        case 51: // c.ueq.fmt
        case 52: // c.olt.fmt
        case 53: // c.ult.fmt
        case 54: // c.ole.fmt
        case 55: // c.ule.fmt
        case 56: // c.sf.fmt
        case 57: // n.ngle.fmt
        case 58: // c.seq.fmt
        case 59: // c.ngl.fmt
        case 60: // c.lt.fmt
        case 61: // c.nge.fmt
        case 62: // c.le.fmt
        case 63: // c.ngt.fmt


        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 31:
        case 34:
        case 35:
        case 38:
        case 39:
        case 40:
        case 41:
        case 42:
        case 43:
        case 44:
        case 45:
        case 46:
        case 47:
            decode_unusable(outbuf, n, pc, op);
            break;
        default:
            /* unreachable */
            abort();
    }
}
