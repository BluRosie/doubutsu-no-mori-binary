/*
 * This file contains autogenerated routines for dispatching and disassembling
 * MIPS opcodes.
 *
 * The code has been generated by mipsgen.
 *
 * See scripts/mipsgen.rb for the code generator framework.
 * See codegen/cgen.rb for C specific information.
 */

static char* format_register(uint32_t re)
{
    char* reg;

    switch (re)
    {
        case 0:
            reg = "$zero";
            break;
        case 1:
            reg = "at";
            break;
        case 2:
            reg = "v0";
            break;
        case 3:
            reg = "v1";
            break;
        case 4:
            reg = "a0";
            break;
        case 5:
            reg = "a1";
            break;
        case 6:
            reg = "a2";
            break;
        case 7:
            reg = "a3";
            break;
        case 8:
            reg = "t0";
            break;
        case 9:
            reg = "t1";
            break;
        case 10:
            reg = "t2";
            break;
        case 11:
            reg = "t3";
            break;
        case 12:
            reg = "t4";
            break;
        case 13:
            reg = "t5";
            break;
        case 14:
            reg = "t6";
            break;
        case 15:
            reg = "t7";
            break;
        case 16:
            reg = "s0";
            break;
        case 17:
            reg = "s1";
            break;
        case 18:
            reg = "s2";
            break;
        case 19:
            reg = "s3";
            break;
        case 20:
            reg = "s4";
            break;
        case 21:
            reg = "s5";
            break;
        case 22:
            reg = "s6";
            break;
        case 23:
            reg = "s7";
            break;
        case 24:
            reg = "t8";
            break;
        case 25:
            reg = "t9";
            break;
        case 26:
            reg = "k0";
            break;
        case 27:
            reg = "k1";
            break;
        case 28:
            reg = "gp";
            break;
        case 29:
            reg = "sp";
            break;
        case 30:
            reg = "fp";
            break;
        case 31:
            reg = "ra";
            break;
    }

    return reg;
}

static void decode_j(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    snprintf(outbuf,n,"j 0x%x",gettarget(pc,op));
}

static void decode_jal(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    snprintf(outbuf,n,"jal 0x%x",gettarget(pc,op));
}

static void decode_beq(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    snprintf(outbuf,n,"beq %s, %s, 0x%x",format_register(getrs(op)),format_register(getrt(op)),getbroff(pc,op));
}

static void decode_bne(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    snprintf(outbuf,n,"bne %s, %s, 0x%x",format_register(getrs(op)),format_register(getrt(op)),getbroff(pc,op));
}

static void decode_blez(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc1f0000, 0x18000000)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    snprintf(outbuf,n,"blez %s, 0x%x",format_register(getrs(op)),getbroff(pc,op));
}

static void decode_bgtz(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc1f0000, 0x1c000000)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    snprintf(outbuf,n,"bgtz %s, 0x%x",format_register(getrs(op)),getbroff(pc,op));
}

static void decode_addi(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    snprintf(outbuf,n,"addi %s, %s, %d",format_register(getrt(op)),format_register(getrs(op)),getsimm(op));
}

static void decode_addiu(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    snprintf(outbuf,n,"addiu %s, %s, %d",format_register(getrt(op)),format_register(getrs(op)),getsimm(op));
}

static void decode_slti(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    snprintf(outbuf,n,"slti %s, %s, %d",format_register(getrt(op)),format_register(getrs(op)),getsimm(op));
}



static void decode_sltiu(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    snprintf(outbuf,n,"sltiu %s, %s, %d",format_register(getrt(op)),format_register(getrs(op)),getsimm(op));
}

static void decode_andi(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    snprintf(outbuf,n,"andi %s, %s, 0x%x",format_register(getrt(op)),format_register(getrs(op)),getimm(op));
}

static void decode_ori(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    snprintf(outbuf,n,"ori %s, %s, 0x%x",format_register(getrt(op)),format_register(getrs(op)),getimm(op));
}

static void decode_xori(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    snprintf(outbuf,n,"xori %s, %s, 0x%x",format_register(getrt(op)),format_register(getrs(op)),getimm(op));
}

static void decode_lui(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffe00000, 0x3c000000)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    snprintf(outbuf,n,"lui %s, 0x%x",format_register(getrt(op)),getimm(op));
}

static void decode_beql(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    snprintf(outbuf,n,"beql %s, %s, 0x%x",format_register(getrs(op)),format_register(getrt(op)),getbroff(pc,op));
}

static void decode_bnel(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    snprintf(outbuf,n,"bnel %s, %s, 0x%x",format_register(getrs(op)),format_register(getrt(op)),getbroff(pc,op));
}

static void decode_blezl(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc1f0000, 0x58000000)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    snprintf(outbuf,n,"blezl %s, 0x%x",format_register(getrs(op)),getbroff(pc,op));
}

static void decode_bgtzl(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc1f0000, 0x5c000000)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    snprintf(outbuf,n,"bgtzl %s, 0x%x",format_register(getrs(op)),getbroff(pc,op));
}

static void decode_lb(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    snprintf(outbuf,n,"lb %s, %d(%s)",format_register(getrt(op)),getoffset(op),format_register(getbase(op)));
}

static void decode_lh(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    snprintf(outbuf,n,"lh %s, %d(%s)",format_register(getrt(op)),getoffset(op),format_register(getbase(op)));
}

static void decode_lwl(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    snprintf(outbuf,n,"lwl %s, %d(%s)",format_register(getrt(op)),getoffset(op),format_register(getbase(op)));
}

static void decode_lw(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    snprintf(outbuf,n,"lw %s, %d(%s)",format_register(getrt(op)),getoffset(op),format_register(getbase(op)));
}

static void decode_lbu(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    snprintf(outbuf,n,"lbu %s, %d(%s)",format_register(getrt(op)),getoffset(op),format_register(getbase(op)));
}

static void decode_lhu(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    snprintf(outbuf,n,"lhu %s, %d(%s)",format_register(getrt(op)),getoffset(op),format_register(getbase(op)));
}

static void decode_lwr(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    snprintf(outbuf,n,"lwr %s, %d(%s)",format_register(getrt(op)),getoffset(op),format_register(getbase(op)));
}

static void decode_sb(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    snprintf(outbuf,n,"sb %s, %d(%s)",format_register(getrt(op)),getoffset(op),format_register(getbase(op)));
}

static void decode_sh(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    snprintf(outbuf,n,"sh %s, %d(%s)",format_register(getrt(op)),getoffset(op),format_register(getbase(op)));
}

static void decode_swl(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    snprintf(outbuf,n,"swl %s, %d(%s)",format_register(getrt(op)),getoffset(op),format_register(getbase(op)));
}

static void decode_sw(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    snprintf(outbuf,n,"sw %s, %d(%s)",format_register(getrt(op)),getoffset(op),format_register(getbase(op)));
}

static void decode_swr(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    snprintf(outbuf,n,"swr %s, %d(%s)",format_register(getrt(op)),getoffset(op),format_register(getbase(op)));
}

static void decode_cache(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    snprintf(outbuf,n,"cache 0x%x, %d(%s)",getcacheop(op),getoffset(op),format_register(getbase(op)));
}

static void decode_ll(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    snprintf(outbuf,n,"ll %s, %d(%s)",format_register(getrt(op)),getoffset(op),format_register(getbase(op)));
}

static void decode_pref(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    decode_illegal(outbuf, n, pc, op);

    // snprintf(outbuf,n,"pref 0x%x, %d(%s)",getprefhint(op),getoffset(op),format_register(getbase(op)));
}

static void decode_sc(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    snprintf(outbuf,n,"sc %s, %d(%s)",format_register(getrt(op)),getoffset(op),format_register(getbase(op)));
}

static void decode_sll(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffe0003f, 0x00000000)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    snprintf(outbuf,n,"sll %s, %s, 0x%x",format_register(getrd(op)),format_register(getrt(op)),getsa(op));
}

static void decode_srl(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffe0003f, 0x00000002)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    snprintf(outbuf,n,"srl %s, %s, 0x%x",format_register(getrd(op)),format_register(getrt(op)),getsa(op));
}

static void decode_sra(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffe0003f, 0x00000003)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    snprintf(outbuf,n,"sra %s, %s, 0x%x",format_register(getrd(op)),format_register(getrt(op)),getsa(op));
}

static void decode_sllv(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 0x00000004)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    snprintf(outbuf,n,"sllv %s, %s, %s",format_register(getrd(op)),format_register(getrt(op)),format_register(getrs(op)));
}

static void decode_srlv(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 0x00000006)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    snprintf(outbuf,n,"srlv %s, %s, %s",format_register(getrd(op)),format_register(getrt(op)),format_register(getrs(op)));
}

static void decode_srav(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 0x00000007)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    snprintf(outbuf,n,"srav %s, %s, %s",format_register(getrd(op)),format_register(getrt(op)),format_register(getrs(op)));
}

static void decode_jr(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc1fffff, 0x00000008)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    snprintf(outbuf,n,"jr %s",format_register(getrs(op)));
}

static void decode_jalr(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc1f07ff, 0x00000009)&&check_jalr(getrs(op), getrd(op))))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    snprintf(outbuf,n,"jalr %s, %s", format_register(getrs(op)), format_register(getrd(op)));
}

static void decode_movz(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    //if (!(check_opcode(op, 0xfc0007ff, 0x0000000a)))
    //{
        decode_illegal(outbuf, n, pc, op);
    //    return;
    //}

    //snprintf(outbuf,n,"movz %s, %s, %s",format_register(getrd(op)),format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_movn(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    //if (!(check_opcode(op, 0xfc0007ff, 0x0000000b)))
    //{
        decode_illegal(outbuf, n, pc, op);
    //    return;
    //}

    //snprintf(outbuf,n,"movn %s, %s, %s",format_register(getrd(op)),format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_syscall(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    snprintf(outbuf,n,"syscall 0x%x",getsyscode(op));
}

static void decode_break(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    snprintf(outbuf,n,"break 0x%x",getsyscode(op));
}

static void decode_sync(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfffff83f, 0x0000000f)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    snprintf(outbuf,n,"sync");
}

static void decode_mfhi(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffff07ff, 0x00000010)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    snprintf(outbuf,n,"mfhi %s",format_register(getrd(op)));
}

static void decode_mthi(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc1fffff, 0x00000011)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    snprintf(outbuf,n,"mthi %s",format_register(getrs(op)));
}

static void decode_mflo(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffff07ff, 0x00000012)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    snprintf(outbuf,n,"mflo %s",format_register(getrd(op)));
}

static void decode_mtlo(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc1fffff, 0x00000013)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    snprintf(outbuf,n,"mtlo %s",format_register(getrs(op)));
}

static void decode_mult(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc00ffff, 0x00000018)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    snprintf(outbuf,n,"mult %s, %s",format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_multu(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc00ffff, 0x00000019)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    snprintf(outbuf,n,"multu %s, %s",format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_div(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc00ffff, 0x0000001a)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    snprintf(outbuf,n,"div %s, %s",format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_divu(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc00ffff, 0x0000001b)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    snprintf(outbuf,n,"divu %s, %s",format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_add(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 0x00000020)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    snprintf(outbuf,n,"add %s, %s, %s",format_register(getrd(op)),format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_addu(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 0x00000021)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    snprintf(outbuf,n,"addu %s, %s, %s",format_register(getrd(op)),format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_sub(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 0x00000022)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    snprintf(outbuf,n,"sub %s, %s, %s",format_register(getrd(op)),format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_subu(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 0x00000023)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    snprintf(outbuf,n,"subu %s, %s, %s",format_register(getrd(op)),format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_and(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 0x00000024)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    snprintf(outbuf,n,"and %s, %s, %s",format_register(getrd(op)),format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_or(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 0x00000025)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    snprintf(outbuf,n,"or %s, %s, %s",format_register(getrd(op)),format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_xor(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 0x00000026)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    snprintf(outbuf,n,"xor %s, %s, %s",format_register(getrd(op)),format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_nor(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 0x00000027)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    snprintf(outbuf,n,"nor %s, %s, %s",format_register(getrd(op)),format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_slt(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 0x0000002a)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    snprintf(outbuf,n,"slt %s, %s, %s",format_register(getrd(op)),format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_sltu(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 0x0000002b)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    snprintf(outbuf,n,"sltu %s, %s, %s",format_register(getrd(op)),format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_tge(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    snprintf(outbuf,n,"tge %s, %s, 0x%x",format_register(getrs(op)),format_register(getrt(op)),gettrapcode(op));
}

static void decode_tgeu(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    snprintf(outbuf,n,"tgeu %s, %s, 0x%x",format_register(getrs(op)),format_register(getrt(op)),gettrapcode(op));
}

static void decode_tlt(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    snprintf(outbuf,n,"tlt %s, %s, 0x%x",format_register(getrs(op)),format_register(getrt(op)),gettrapcode(op));
}

static void decode_tltu(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    snprintf(outbuf,n,"tltu %s, %s, 0x%x",format_register(getrs(op)),format_register(getrt(op)),gettrapcode(op));
}

static void decode_teq(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    snprintf(outbuf,n,"teq %s, %s, 0x%x",format_register(getrs(op)),format_register(getrt(op)),gettrapcode(op));
}

static void decode_tne(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    snprintf(outbuf,n,"tne %s, %s, 0x%x",format_register(getrs(op)),format_register(getrt(op)),gettrapcode(op));
}

static void decode_madd(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    //if (!(check_opcode(op, 0xfc00ffff, 0x70000000)))
    //{
        decode_illegal(outbuf, n, pc, op);
    //    return;
    //}

    //snprintf(outbuf,n,"madd %s, %s",format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_maddu(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    //if (!(check_opcode(op, 0xfc00ffff, 0x70000001)))
    //{
        decode_illegal(outbuf, n, pc, op);
    //    return;
    //}

    //snprintf(outbuf,n,"maddu %s, %s",format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_mul(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 0x70000002)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    snprintf(outbuf,n,"mul %s, %s, %s",format_register(getrd(op)),format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_msub(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    //if (!(check_opcode(op, 0xfc00ffff, 0x70000004)))
    //{
        decode_illegal(outbuf, n, pc, op);
    //    return;
    //}

    //snprintf(outbuf,n,"msub %s, %s",format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_msubu(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    //if (!(check_opcode(op, 0xfc00ffff, 0x70000005)))
    //{
        decode_illegal(outbuf, n, pc, op);
    //    return;
    //}

    //snprintf(outbuf,n,"msubu %s, %s",format_register(getrs(op)),format_register(getrt(op)));
}

static void decode_clz(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 0x70000020)&&check_cl(getrt(op), getrd(op))))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    snprintf(outbuf,n,"clz %s, %s",format_register(getrd(op)),format_register(getrs(op)));
}

static void decode_clo(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xfc0007ff, 0x70000021)&&check_cl(getrt(op), getrd(op))))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    snprintf(outbuf,n,"clo %s, %s",format_register(getrd(op)),format_register(getrs(op)));
}

static void decode_sdbbp(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    snprintf(outbuf,n,"sdbbp 0x%x",getsyscode(op));
}

static void decode_bltz(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    snprintf(outbuf,n,"bltz %s, 0x%x",format_register(getrs(op)),getbroff(pc,op));
}

static void decode_bgez(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    snprintf(outbuf,n,"bgez %s, 0x%x",format_register(getrs(op)),getbroff(pc,op));
}

static void decode_bltzl(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    snprintf(outbuf,n,"bltzl %s, 0x%x",format_register(getrs(op)),getbroff(pc,op));
}

static void decode_bgezl(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    snprintf(outbuf,n,"bgezl %s, 0x%x",format_register(getrs(op)),getbroff(pc,op));
}

static void decode_tgei(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    snprintf(outbuf,n,"tgei %s, %d",format_register(getrs(op)),getsimm(op));
}

static void decode_tgeiu(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    snprintf(outbuf,n,"tgeiu %s, %d",format_register(getrs(op)),getsimm(op));
}

static void decode_tlti(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    snprintf(outbuf,n,"tlti %s, %d",format_register(getrs(op)),getsimm(op));
}

static void decode_tltiu(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    snprintf(outbuf,n,"tltiu %s, %d",format_register(getrs(op)),getsimm(op));
}

static void decode_teqi(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    snprintf(outbuf,n,"teqi %s, %d",format_register(getrs(op)),getsimm(op));
}

static void decode_tnei(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    snprintf(outbuf,n,"tnei %s, %d",format_register(getrs(op)),getsimm(op));
}

static void decode_bltzal(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    snprintf(outbuf,n,"bltzal %s, 0x%x",format_register(getrs(op)),getbroff(pc,op));
}

static void decode_bgezal(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    snprintf(outbuf,n,"bgezal %s, 0x%x",format_register(getrs(op)),getbroff(pc,op));
}

static void decode_bltzall(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    snprintf(outbuf,n,"bltzall %s, 0x%x",format_register(getrs(op)),getbroff(pc,op));
}

static void decode_bgezall(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    snprintf(outbuf,n,"bgezall %s, 0x%x",format_register(getrs(op)),getbroff(pc,op));
}

static void decode_mfc0(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffe007f8, 0x40000000)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    snprintf(outbuf,n,"mfc0 %s, %s, %d",format_register(getrt(op)),format_register(getrd(op)),getsel(op));
}

static void decode_mtc0(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffe007f8, 0x40800000)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    snprintf(outbuf,n,"mtc0 %s, %s, %d",format_register(getrt(op)),format_register(getrd(op)),getsel(op));
}

static void decode_tlbr(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffffffff, 0x42000001)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    snprintf(outbuf,n,"tlbr");
}

static void decode_tlbwi(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffffffff, 0x42000002)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    snprintf(outbuf,n,"tlbwi");
}

static void decode_tlbwr(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffffffff, 0x42000006)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    snprintf(outbuf,n,"tlbwr");
}

static void decode_tlbp(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffffffff, 0x42000008)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    snprintf(outbuf,n,"tlbp");
}

static void decode_eret(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffffffff, 0x42000018)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    snprintf(outbuf,n,"eret");
}

static void decode_deret(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    if (!(check_opcode(op, 0xffffffff, 0x4200001f)))
    {
        decode_illegal(outbuf, n, pc, op);
        return;
    }

    snprintf(outbuf,n,"deret");
}

static void decode_wait(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    snprintf(outbuf,n,"wait 0x%x",getwaitcode(op));
}

static void decode_OPCODE(char *outbuf, size_t n, uint32_t pc, uint32_t op);
static void decode_SPC1(char *outbuf, size_t n, uint32_t pc, uint32_t op);
static void decode_SPC2(char *outbuf, size_t n, uint32_t pc, uint32_t op);
static void decode_R(char *outbuf, size_t n, uint32_t pc, uint32_t op);
static void decode_COP0(char *outbuf, size_t n, uint32_t pc, uint32_t op);
static void decode_CO(char *outbuf, size_t n, uint32_t pc, uint32_t op);
static void decode_OPCODE(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    switch (getopcode(op))
    {
        case 0:
            decode_SPC1(outbuf, n, pc, op);
            break;
        case 1:
            decode_R(outbuf, n, pc, op);
            break;
        case 2:
            decode_j(outbuf, n, pc, op);
            break;
        case 3:
            decode_jal(outbuf, n, pc, op);
            break;
        case 4:
            decode_beq(outbuf, n, pc, op);
            break;
        case 5:
            decode_bne(outbuf, n, pc, op);
            break;
        case 6:
            decode_blez(outbuf, n, pc, op);
            break;
        case 7:
            decode_bgtz(outbuf, n, pc, op);
            break;
        case 8:
            decode_addi(outbuf, n, pc, op);
            break;
        case 9:
            decode_addiu(outbuf, n, pc, op);
            break;
        case 10:
            decode_slti(outbuf, n, pc, op);
            break;
        case 11:
            decode_sltiu(outbuf, n, pc, op);
            break;
        case 12:
            decode_andi(outbuf, n, pc, op);
            break;
        case 13:
            decode_ori(outbuf, n, pc, op);
            break;
        case 14:
            decode_xori(outbuf, n, pc, op);
            break;
        case 15:
            decode_lui(outbuf, n, pc, op);
            break;
        case 16:
            decode_COP0(outbuf, n, pc, op);
            break;
        case 17:
        case 18:
        case 19:
        case 49:
        case 50:
        case 53:
        case 54:
        case 57:
        case 58:
        case 61:
        case 62:
            decode_unusable(outbuf, n, pc, op);
            break;
        case 20:
            decode_beql(outbuf, n, pc, op);
            break;
        case 21:
            decode_bnel(outbuf, n, pc, op);
            break;
        case 22:
            decode_blezl(outbuf, n, pc, op);
            break;
        case 23:
            decode_bgtzl(outbuf, n, pc, op);
            break;
        case 24:
        case 25:
        case 26:
        case 27:
        case 29:
        case 30:
        case 31:
        case 39:
        case 44:
        case 45:
        case 52:
        case 55:
        case 59:
        case 60:
        case 63:
            decode_reserved(outbuf, n, pc, op);
            break;
        case 28:
            decode_SPC2(outbuf, n, pc, op);
            break;
        case 32:
            decode_lb(outbuf, n, pc, op);
            break;
        case 33:
            decode_lh(outbuf, n, pc, op);
            break;
        case 34:
            decode_lwl(outbuf, n, pc, op);
            break;
        case 35:
            decode_lw(outbuf, n, pc, op);
            break;
        case 36:
            decode_lbu(outbuf, n, pc, op);
            break;
        case 37:
            decode_lhu(outbuf, n, pc, op);
            break;
        case 38:
            decode_lwr(outbuf, n, pc, op);
            break;
        case 40:
            decode_sb(outbuf, n, pc, op);
            break;
        case 41:
            decode_sh(outbuf, n, pc, op);
            break;
        case 42:
            decode_swl(outbuf, n, pc, op);
            break;
        case 43:
            decode_sw(outbuf, n, pc, op);
            break;
        case 46:
            decode_swr(outbuf, n, pc, op);
            break;
        case 47:
            decode_cache(outbuf, n, pc, op);
            break;
        case 48:
            decode_ll(outbuf, n, pc, op);
            break;
        case 51:
            decode_pref(outbuf, n, pc, op);
            break;
        case 56:
            decode_sc(outbuf, n, pc, op);
            break;
        default:
            /* unreachable */
            abort();
    }
}

static void decode_SPC1(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    switch (getfunction(op))
    {
        case 0:
            decode_sll(outbuf, n, pc, op);
            break;
        case 1:
            decode_unusable(outbuf, n, pc, op);
            break;
        case 2:
            decode_srl(outbuf, n, pc, op);
            break;
        case 3:
            decode_sra(outbuf, n, pc, op);
            break;
        case 4:
            decode_sllv(outbuf, n, pc, op);
            break;
        case 5:
        case 14:
        case 20:
        case 21:
        case 22:
        case 23:
        case 28:
        case 29:
        case 30:
        case 31:
        case 40:
        case 41:
        case 44:
        case 45:
        case 46:
        case 47:
        case 53:
        case 55:
        case 56:
        case 57:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
            decode_reserved(outbuf, n, pc, op);
            break;
        case 6:
            decode_srlv(outbuf, n, pc, op);
            break;
        case 7:
            decode_srav(outbuf, n, pc, op);
            break;
        case 8:
            decode_jr(outbuf, n, pc, op);
            break;
        case 9:
            decode_jalr(outbuf, n, pc, op);
            break;
        case 10:
            decode_movz(outbuf, n, pc, op);
            break;
        case 11:
            decode_movn(outbuf, n, pc, op);
            break;
        case 12:
            decode_syscall(outbuf, n, pc, op);
            break;
        case 13:
            decode_break(outbuf, n, pc, op);
            break;
        case 15:
            decode_sync(outbuf, n, pc, op);
            break;
        case 16:
            decode_mfhi(outbuf, n, pc, op);
            break;
        case 17:
            decode_mthi(outbuf, n, pc, op);
            break;
        case 18:
            decode_mflo(outbuf, n, pc, op);
            break;
        case 19:
            decode_mtlo(outbuf, n, pc, op);
            break;
        case 24:
            decode_mult(outbuf, n, pc, op);
            break;
        case 25:
            decode_multu(outbuf, n, pc, op);
            break;
        case 26:
            decode_div(outbuf, n, pc, op);
            break;
        case 27:
            decode_divu(outbuf, n, pc, op);
            break;
        case 32:
            decode_add(outbuf, n, pc, op);
            break;
        case 33:
            decode_addu(outbuf, n, pc, op);
            break;
        case 34:
            decode_sub(outbuf, n, pc, op);
            break;
        case 35:
            decode_subu(outbuf, n, pc, op);
            break;
        case 36:
            decode_and(outbuf, n, pc, op);
            break;
        case 37:
            decode_or(outbuf, n, pc, op);
            break;
        case 38:
            decode_xor(outbuf, n, pc, op);
            break;
        case 39:
            decode_nor(outbuf, n, pc, op);
            break;
        case 42:
            decode_slt(outbuf, n, pc, op);
            break;
        case 43:
            decode_sltu(outbuf, n, pc, op);
            break;
        case 48:
            decode_tge(outbuf, n, pc, op);
            break;
        case 49:
            decode_tgeu(outbuf, n, pc, op);
            break;
        case 50:
            decode_tlt(outbuf, n, pc, op);
            break;
        case 51:
            decode_tltu(outbuf, n, pc, op);
            break;
        case 52:
            decode_teq(outbuf, n, pc, op);
            break;
        case 54:
            decode_tne(outbuf, n, pc, op);
            break;
        default:
            /* unreachable */
            abort();
    }
}

static void decode_SPC2(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    switch (getfunction(op))
    {
        case 0:
            decode_madd(outbuf, n, pc, op);
            break;
        case 1:
            decode_maddu(outbuf, n, pc, op);
            break;
        case 2:
            decode_mul(outbuf, n, pc, op);
            break;
        case 3:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 31:
        case 34:
        case 35:
        case 36:
        case 37:
        case 38:
        case 39:
        case 40:
        case 41:
        case 42:
        case 43:
        case 44:
        case 45:
        case 46:
        case 47:
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
            decode_reserved(outbuf, n, pc, op);
            break;
        case 4:
            decode_msub(outbuf, n, pc, op);
            break;
        case 5:
            decode_msubu(outbuf, n, pc, op);
            break;
        case 32:
            decode_clz(outbuf, n, pc, op);
            break;
        case 33:
            decode_clo(outbuf, n, pc, op);
            break;
        case 63:
            decode_sdbbp(outbuf, n, pc, op);
            break;
        default:
            /* unreachable */
            abort();
    }
}

static void decode_R(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    switch (getrt(op))
    {
        case 0:
            decode_bltz(outbuf, n, pc, op);
            break;
        case 1:
            decode_bgez(outbuf, n, pc, op);
            break;
        case 2:
            decode_bltzl(outbuf, n, pc, op);
            break;
        case 3:
            decode_bgezl(outbuf, n, pc, op);
            break;
        case 4:
        case 5:
        case 6:
        case 7:
        case 13:
        case 15:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 31:
            decode_reserved(outbuf, n, pc, op);
            break;
        case 8:
            decode_tgei(outbuf, n, pc, op);
            break;
        case 9:
            decode_tgeiu(outbuf, n, pc, op);
            break;
        case 10:
            decode_tlti(outbuf, n, pc, op);
            break;
        case 11:
            decode_tltiu(outbuf, n, pc, op);
            break;
        case 12:
            decode_teqi(outbuf, n, pc, op);
            break;
        case 14:
            decode_tnei(outbuf, n, pc, op);
            break;
        case 16:
            decode_bltzal(outbuf, n, pc, op);
            break;
        case 17:
            decode_bgezal(outbuf, n, pc, op);
            break;
        case 18:
            decode_bltzall(outbuf, n, pc, op);
            break;
        case 19:
            decode_bgezall(outbuf, n, pc, op);
            break;
        default:
            /* unreachable */
            abort();
    }
}

static void decode_COP0(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    switch (getrs(op))
    {
        case 0:
            decode_mfc0(outbuf, n, pc, op);
            break;
        case 1:
        case 2:
        case 3:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
            decode_reserved(outbuf, n, pc, op);
            break;
        case 4:
            decode_mtc0(outbuf, n, pc, op);
            break;
        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 31:
            decode_CO(outbuf, n, pc, op);
            break;
        default:
            /* unreachable */
            abort();
    }
}

static void decode_CO(char *outbuf, size_t n, uint32_t pc, uint32_t op)
{
    switch (getfunction(op))
    {
        case 0:
        case 3:
        case 4:
        case 5:
        case 7:
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 33:
        case 34:
        case 35:
        case 36:
        case 37:
        case 38:
        case 39:
        case 40:
        case 41:
        case 42:
        case 43:
        case 44:
        case 45:
        case 46:
        case 47:
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
            decode_reserved(outbuf, n, pc, op);
            break;
        case 1:
            decode_tlbr(outbuf, n, pc, op);
            break;
        case 2:
            decode_tlbwi(outbuf, n, pc, op);
            break;
        case 6:
            decode_tlbwr(outbuf, n, pc, op);
            break;
        case 8:
            decode_tlbp(outbuf, n, pc, op);
            break;
        case 24:
            decode_eret(outbuf, n, pc, op);
            break;
        case 31:
            decode_deret(outbuf, n, pc, op);
            break;
        case 32:
            decode_wait(outbuf, n, pc, op);
            break;
        default:
            /* unreachable */
            abort();
    }
}

